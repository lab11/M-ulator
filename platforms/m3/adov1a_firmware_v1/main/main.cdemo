//*******************************************************************
//Author: Sechang Oh
//Description: Leidos Trestle Gen2 
//    v1.0: created. Modified from 'Leidos_dorado_Gen3' 12/14/2018
//    v1a02: GPIO functions                             03/19/2019
//    v2a03: 2.5V VBAT, self-booting support            08/14/2019
//*******************************************************************
#include "PREv20.h"
#include "PREv20_RF.h"
#include "ADOv6VB_RF.h"
#include "PMUv7_RF.h"
#include "MRRv10_RF.h"
#include "mbus.h"

#define ENUMID 0xDEADBEE3

#include "DFT_LUT.txt"
#include "DCT_PHS.txt"

////////////////////////////////////////
// uncomment this for debug 
#define DEBUG_MODE          // Test VDD ON in ULP
#define DEBUG_MBUS_MSG      // Debug MBus message
/////////////////////////////////////////
#define SNT_ADDR 0x2
#define MRR_ADDR 0x3
#define FLP1_ADDR 0x4
#define FLP2_ADDR 0x5
#define FLP3_ADDR 0x6
#define FLP4_ADDR 0x7
#define ADO_ADDR 0x8
#define PMU_ADDR 0x9
//#define WAKEUP_PERIOD_PARKING 30000 // About 2 hours (PRCv17)

// System parameters
#define MBUS_DELAY 100 // Amount of delay between successive messages; 100: ~7ms (MOD Audio Debug Stack)
//#define WAKEUP_PERIOD_LDO 5 // About 1 sec (PRCv17)

// CP parameter
#define CP_DELAY 50000 // Amount of delay for ADO charge pump charging-up; ~3.5s

#define TIMERWD_VAL 0xFFFFF // 0xFFFFF about 13 sec with Y5 run default clock (PRCv17)
#define TIMER32_VAL 0x50000 // 0x20000 about 1 sec with Y5 run default clock (PRCv17)

// GPIO pins
//#define GPIO0_IRQ  0

#define EP_MODE     ((volatile uint32_t *) 0xA0000028)

// Radio configurations
#define RADIO_DATA_LENGTH 192 // 96 bit header, 96 bit data
#define WAKEUP_PERIOD_RADIO_INIT 0xA // About 1.5 sec (PRCv18)
#define WAKEUP_PERIOD_SNT 0x20 // About 3 sec (PRCv18)

#define TEMP_STORAGE_SIZE 8192 // MEMv1: 16kB, 8k 2-byte data

// Flash access parameters
#define _SIZE_TEMP_ 64
#define _LOG2_TEMP_ 6   // = log2(_SIZE_TEMP_)
#define _ITER_TEMP_ 128  // = 8192 / _SIZE_TEMP_

//********************************************************************
// Global Variables
//********************************************************************
// "static" limits the variables to this file, giving compiler more freedom
// "volatile" should only be used for MMIO --> ensures memory storage
//volatile uint32_t irq_history;
uint32_t temp_storage[_SIZE_TEMP_];
volatile uint32_t enumerated;
volatile uint32_t wakeup_data;
volatile uint32_t wfi_timeout_flag;
volatile uint32_t error_code;
volatile uint32_t pmu_sar_conv_ratio_val_test_on;
volatile uint32_t pmu_sar_conv_ratio_val_test_off;
volatile uint32_t read_data_batadc;
volatile uint32_t read_data_batadc_diff;
volatile uint32_t mem_read_data[2];

volatile prev20_r0B_t prev20_r0B = PREv20_R0B_DEFAULT;
volatile prev20_r19_t prev20_r19 = PREv20_R19_DEFAULT;
volatile prev20_r1A_t prev20_r1A = PREv20_R1A_DEFAULT;
volatile prev20_r1C_t prev20_r1C = PREv20_R1C_DEFAULT;
volatile prev20_r1F_t prev20_r1F = PREv20_R1F_DEFAULT;

volatile adov6vb_r00_t adov6vb_r00 = ADOv6VB_R00_DEFAULT;
volatile adov6vb_r04_t adov6vb_r04 = ADOv6VB_R04_DEFAULT;
volatile adov6vb_r07_t adov6vb_r07 = ADOv6VB_R07_DEFAULT;
volatile adov6vb_r0B_t adov6vb_r0B = ADOv6VB_R0B_DEFAULT;
volatile adov6vb_r0D_t adov6vb_r0D = ADOv6VB_R0D_DEFAULT;
volatile adov6vb_r0E_t adov6vb_r0E = ADOv6VB_R0E_DEFAULT;
volatile adov6vb_r0F_t adov6vb_r0F = ADOv6VB_R0F_DEFAULT;
volatile adov6vb_r10_t adov6vb_r10 = ADOv6VB_R10_DEFAULT;
volatile adov6vb_r11_t adov6vb_r11 = ADOv6VB_R11_DEFAULT;
volatile adov6vb_r12_t adov6vb_r12 = ADOv6VB_R12_DEFAULT;
volatile adov6vb_r13_t adov6vb_r13 = ADOv6VB_R13_DEFAULT;
volatile adov6vb_r14_t adov6vb_r14 = ADOv6VB_R14_DEFAULT;
volatile adov6vb_r15_t adov6vb_r15 = ADOv6VB_R15_DEFAULT;
volatile adov6vb_r16_t adov6vb_r16 = ADOv6VB_R16_DEFAULT;
volatile adov6vb_r17_t adov6vb_r17 = ADOv6VB_R17_DEFAULT;
volatile adov6vb_r18_t adov6vb_r18 = ADOv6VB_R18_DEFAULT;
volatile adov6vb_r19_t adov6vb_r19 = ADOv6VB_R19_DEFAULT;
volatile adov6vb_r1B_t adov6vb_r1B = ADOv6VB_R1B_DEFAULT;
volatile adov6vb_r1C_t adov6vb_r1C = ADOv6VB_R1C_DEFAULT;


uint32_t read_data[128];
volatile uint8_t direction_gpio;

static void operation_sleep_notimer(void);
static void operation_sleep_timer(void);
static void pmu_set_sar_override(uint32_t val);
static void pmu_set_sleep_clk(uint8_t r, uint8_t l, uint8_t base, uint8_t l_1p2);
static void pmu_set_active_clk(uint8_t r, uint8_t l, uint8_t base, uint8_t l_1p2);

volatile uint32_t radio_tx_option;
volatile uint32_t radio_ready;
volatile uint32_t radio_on;
volatile uint32_t mrr_freq_hopping;
volatile uint32_t mrr_freq_hopping_step;
volatile uint32_t mrr_cfo_val_fine_min;
volatile uint32_t RADIO_PACKET_DELAY;
volatile uint32_t radio_packet_count;
volatile uint32_t num_total_16b_packet;
volatile uint32_t TEMP_CALIB_A;
volatile uint32_t TEMP_CALIB_B;
volatile uint32_t NUM_MEAS_USER;

volatile mrrv10_r00_t mrrv10_r00 = MRRv10_R00_DEFAULT;
volatile mrrv10_r01_t mrrv10_r01 = MRRv10_R01_DEFAULT;
volatile mrrv10_r02_t mrrv10_r02 = MRRv10_R02_DEFAULT;
volatile mrrv10_r03_t mrrv10_r03 = MRRv10_R03_DEFAULT;
volatile mrrv10_r04_t mrrv10_r04 = MRRv10_R04_DEFAULT;
volatile mrrv10_r07_t mrrv10_r07 = MRRv10_R07_DEFAULT;
volatile mrrv10_r11_t mrrv10_r11 = MRRv10_R11_DEFAULT;
volatile mrrv10_r12_t mrrv10_r12 = MRRv10_R12_DEFAULT;
volatile mrrv10_r13_t mrrv10_r13 = MRRv10_R13_DEFAULT;
volatile mrrv10_r14_t mrrv10_r14 = MRRv10_R14_DEFAULT;
volatile mrrv10_r15_t mrrv10_r15 = MRRv10_R15_DEFAULT;
volatile mrrv10_r16_t mrrv10_r16 = MRRv10_R16_DEFAULT;
volatile mrrv10_r1F_t mrrv10_r1F = MRRv10_R1F_DEFAULT;
volatile mrrv10_r21_t mrrv10_r21 = MRRv10_R21_DEFAULT;

//***************************************************
// CRC16 Encoding
//***************************************************
#define DATA_LEN 96
#define CRC_LEN 16

uint32_t* crcEnc16(uint32_t data2, uint32_t data1, uint32_t data0)
{
    // intialization
    uint32_t i;
	
    uint16_t poly = 0xc002;
    uint16_t poly_not = ~poly;
    uint16_t remainder = 0x0000;
    uint16_t remainder_shift = 0x0000;
    data2 = (data2 << CRC_LEN) + (data1 >> CRC_LEN);
    data1 = (data1 << CRC_LEN) + (data0 >> CRC_LEN);
    data0 = data0 << CRC_LEN;
    
    // LFSR
    uint16_t input_bit;
    for (i = 0; i < DATA_LEN; i++)
    {
        uint16_t MSB;
        if (remainder > 0x7fff)
		MSB = 0xffff;
        else
		MSB = 0x0000;
        
        if (i < 32)
		input_bit = ((data2 << i) > 0x7fffffff);
        else if (i < 64)
		input_bit = (data1 << (i-32)) > 0x7fffffff;
        else
		input_bit = (data0 << (i-64)) > 0x7fffffff;
		
        remainder_shift = remainder << 1;
        remainder = ((poly&((remainder_shift)^MSB))|((poly_not)&(remainder_shift)))
		+ (input_bit^(remainder > 0x7fff));
	}
	
    data0 = data0 + remainder;
	
    static uint32_t msg_out[3];
    msg_out[0] = data2;
    msg_out[1] = data1;
    msg_out[2] = data0;
	
    return msg_out;    
}

//***************************************************
// Timeout Functions
//***************************************************

static void set_timer32_timeout(uint32_t val){
	// Use Timer32 as timeout counter
    wfi_timeout_flag = 0;
	config_timer32(val, 1, 0, 0);
}

static void stop_timer32_timeout_check(uint32_t code){
	// Turn off Timer32
	*TIMER32_GO = 0;
	if (wfi_timeout_flag){
		wfi_timeout_flag = 0;
		error_code = code;
		mbus_write_message32(0xFA, error_code);
	}
}

//***************************************************
// MRR Functions
//***************************************************
static void mrr_ldo_vref_on(){
    mrrv10_r04.LDO_EN_VREF    = 1;
    mbus_remote_register_write(MRR_ADDR,0x4,mrrv10_r04.as_int);
}

static void mrr_ldo_power_on(){
    mrrv10_r04.LDO_EN_IREF    = 1;
    mrrv10_r04.LDO_EN_LDO    = 1;
    mbus_remote_register_write(MRR_ADDR,0x4,mrrv10_r04.as_int);
}
static void mrr_ldo_power_off(){
    mrrv10_r04.LDO_EN_VREF    = 0;
    mrrv10_r04.LDO_EN_IREF    = 0;
    mrrv10_r04.LDO_EN_LDO    = 0;
    mbus_remote_register_write(MRR_ADDR,0x4,mrrv10_r04.as_int);
}

static void radio_power_on(){
	// Turn off PMU ADC
	//pmu_adc_disable();
	
	// Need to speed up sleep pmu clock
	//pmu_set_sleep_radio();
	
	// New for MRRv10
	mrr_ldo_vref_on();
	
    // Turn off Current Limter Briefly
    mrrv10_r00.MRR_CL_EN = 0;  //Enable CL
    mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
	// Set decap to parallel
	mrrv10_r03.MRR_DCP_S_OW = 0;  //TX_Decap S (forced charge decaps)
	mbus_remote_register_write(MRR_ADDR,3,mrrv10_r03.as_int);
	mrrv10_r03.MRR_DCP_P_OW = 1;  //RX_Decap P 
	mbus_remote_register_write(MRR_ADDR,3,mrrv10_r03.as_int);
    delay(MBUS_DELAY);
	
	// Set decap to series
	mrrv10_r03.MRR_DCP_P_OW = 0;  //RX_Decap P 
	mbus_remote_register_write(MRR_ADDR,3,mrrv10_r03.as_int);
	mrrv10_r03.MRR_DCP_S_OW = 1;  //TX_Decap S (forced charge decaps)
	mbus_remote_register_write(MRR_ADDR,3,mrrv10_r03.as_int);
    delay(MBUS_DELAY);
	
	// Current Limter set-up 
	mrrv10_r00.MRR_CL_CTRL = 16; //Set CL 1: unlimited, 8: 30uA, 16: 3uA
	mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
    radio_on = 1;
	
	// New for MRRv10
	mrr_ldo_power_on();
	
    // Turn on Current Limter
    mrrv10_r00.MRR_CL_EN = 1;  //Enable CL
    mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
    // Release timer power-gate
    mrrv10_r04.RO_EN_RO_V1P2 = 1;  //Use V1P2 for TIMER
    //mrrv10_r04.RO_EN_RO_LDO = 1;  //Use LDO for TIMER
    mbus_remote_register_write(MRR_ADDR,0x04,mrrv10_r04.as_int);
    delay(MBUS_DELAY);
	
	// Turn on timer
    mrrv10_r04.RO_RESET = 0;  //Release Reset TIMER
    mbus_remote_register_write(MRR_ADDR,0x04,mrrv10_r04.as_int);
    delay(MBUS_DELAY);
	
    mrrv10_r04.RO_EN_CLK = 1; //Enable CLK TIMER
    mbus_remote_register_write(MRR_ADDR,0x04,mrrv10_r04.as_int);
    delay(MBUS_DELAY);
	
    mrrv10_r04.RO_ISOLATE_CLK = 0; //Set Isolate CLK to 0 TIMER
    mbus_remote_register_write(MRR_ADDR,0x04,mrrv10_r04.as_int);
	
    // Release FSM Sleep
    mrrv10_r11.MRR_RAD_FSM_SLEEP = 0;  // Power on BB
    mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
	delay(MBUS_DELAY*5); // Freq stab
	
}

static void radio_power_off(){
	// Need to restore sleep pmu clock
	
	// Enable PMU ADC
	//pmu_adc_enable();
	
    // In case continuous mode was running
	mrrv10_r16.MRR_RAD_FSM_CONT_PULSE_MODEb = 1;
	mbus_remote_register_write(MRR_ADDR,0x16,mrrv10_r16.as_int);
	
    // Turn off FSM
    mrrv10_r03.MRR_TRX_ISOLATEN = 0;     //set ISOLATEN 0
    mbus_remote_register_write(MRR_ADDR,0x03,mrrv10_r03.as_int);
	
    mrrv10_r11.MRR_RAD_FSM_EN = 0;  //Stop BB
    mrrv10_r11.MRR_RAD_FSM_RSTN = 0;  //RST BB
    mrrv10_r11.MRR_RAD_FSM_SLEEP = 1;
    mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
	
    // Turn off Current Limter Briefly
    mrrv10_r00.MRR_CL_EN = 0;  //Enable CL
    mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
	// Current Limter set-up 
	mrrv10_r00.MRR_CL_CTRL = 16; //Set CL 1: unlimited, 8: 30uA, 16: 3uA
	mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
    // Turn on Current Limter
    mrrv10_r00.MRR_CL_EN = 1;  //Enable CL
    mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
	// Turn off RO
    mrrv10_r04.RO_RESET = 1;  //Release Reset TIMER
    mrrv10_r04.RO_EN_CLK = 0; //Enable CLK TIMER
    mrrv10_r04.RO_ISOLATE_CLK = 1; //Set Isolate CLK to 0 TIMER
    mbus_remote_register_write(MRR_ADDR,0x04,mrrv10_r04.as_int);
	
	mrr_ldo_power_off();
	
    // Enable timer power-gate
    mrrv10_r04.RO_EN_RO_V1P2 = 0;  //Use V1P2 for TIMER
    //mrrv10_r04.RO_EN_RO_LDO = 0;  //Use LDO for TIMER
    mbus_remote_register_write(MRR_ADDR,0x04,mrrv10_r04.as_int);
	
    radio_on = 0;
	radio_ready = 0;
	
}

static void mrr_configure_pulse_width_long(){
	
    mrrv10_r12.MRR_RAD_FSM_TX_PW_LEN = 24; //100us PW
    mrrv10_r13.MRR_RAD_FSM_TX_C_LEN = 100; // (PW_LEN+1):C_LEN=1:32
    mrrv10_r12.MRR_RAD_FSM_TX_PS_LEN = 49; // PW=PS   
	
    mbus_remote_register_write(MRR_ADDR,0x12,mrrv10_r12.as_int);
    mbus_remote_register_write(MRR_ADDR,0x13,mrrv10_r13.as_int);
}

static void send_radio_data_mrr_sub1(){
	
	// Use timer32 as timeout counter
	set_timer32_timeout(TIMER32_VAL);
	
    // Turn on Current Limter
    mrrv10_r00.MRR_CL_EN = 1;
    mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
    // Fire off data
	mrrv10_r11.MRR_RAD_FSM_EN = 1;  //Start BB
	mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
	
	// Wait for radio response
	WFI();
	stop_timer32_timeout_check(0x3);
	
    // Turn off Current Limter
    mrrv10_r00.MRR_CL_EN = 0;
    mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
	mrrv10_r11.MRR_RAD_FSM_EN = 0;
	mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
}

static void send_radio_data_mrr(uint32_t last_packet, uint8_t radio_packet_prefix, uint32_t radio_data){
	// Sends 192 bit packet, of which 96b is actual data
	// MRR REG_9: reserved for header
	// MRR REG_A: reserved for header
	// MRR REG_B: reserved for header
	// MRR REG_C: reserved for header
	// MRR REG_D: DATA[23:0]
	// MRR REG_E: DATA[47:24]
	// MRR REG_F: DATA[71:48]
	// MRR REG_10: DATA[95:72]
	
	// CRC16 Encoding 
    uint32_t* output_data;
    //output_data = crcEnc16(((radio_packet_count & 0xFF)<<8) | radio_packet_prefix, (radio_data_2 <<16) | ((radio_data_1 & 0xFFFFFF) >>8), (radio_data_1 << 24) | (radio_data_0 & 0xFFFFFF));
    output_data = crcEnc16(((read_data_batadc & 0xFF)<<8) | ((radio_packet_prefix & 0xF)<<4) | ((radio_packet_count>>16)&0xF), ((radio_packet_count & 0xFFFF)<<16) | (*REG_CHIP_ID & 0xFFFF), radio_data);
	
    mbus_remote_register_write(MRR_ADDR,0xD,radio_data & 0xFFFFFF);
    mbus_remote_register_write(MRR_ADDR,0xE,(*REG_CHIP_ID<<8)|(radio_data>>24));
    mbus_remote_register_write(MRR_ADDR,0xF,(radio_packet_prefix<<20)|(radio_packet_count&0xFFFFF));
    mbus_remote_register_write(MRR_ADDR,0x10,((output_data[2] & 0xFFFF)/*CRC16*/<<8)|(read_data_batadc&0xFF));
	
    if (!radio_ready){
		radio_ready = 1;
		
		// Release FSM Reset
		mrrv10_r11.MRR_RAD_FSM_RSTN = 1;  //UNRST BB
		mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
		delay(MBUS_DELAY);
		
    	mrrv10_r03.MRR_TRX_ISOLATEN = 1;     //set ISOLATEN 1, let state machine control
    	mbus_remote_register_write(MRR_ADDR,0x03,mrrv10_r03.as_int);
		delay(MBUS_DELAY);
		
	}
	
	// Current Limter set-up 
	mrrv10_r00.MRR_CL_CTRL = 1; //Set CL 1: unlimited, 8: 30uA, 16: 3uA
	mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
	uint32_t count = 0;
	uint32_t mrr_cfo_val_fine = 0;
	uint32_t num_packets = 1;
	if (mrr_freq_hopping) num_packets = mrr_freq_hopping;
	
	// New for mrrv10
	mrr_cfo_val_fine = mrr_cfo_val_fine_min;
	
	while (count < num_packets){
		#ifdef DEBUG_MBUS_MSG
			mbus_write_message32(0xCE, mrr_cfo_val_fine);
		#endif
		
		mrrv10_r01.MRR_TRX_CAP_ANTP_TUNE_FINE = mrr_cfo_val_fine; 
		mrrv10_r01.MRR_TRX_CAP_ANTN_TUNE_FINE = mrr_cfo_val_fine;
		mbus_remote_register_write(MRR_ADDR,0x01,mrrv10_r01.as_int);
		send_radio_data_mrr_sub1();
		count++;
		if (count < num_packets){
			delay(RADIO_PACKET_DELAY);
		}
		mrr_cfo_val_fine = mrr_cfo_val_fine + mrr_freq_hopping_step; // 1: 0.8MHz, 2: 1.6MHz step
	}
	
	radio_packet_count++;
	
	if (last_packet){
		radio_ready = 0;
		radio_power_off();
		}else{
		mrrv10_r11.MRR_RAD_FSM_EN = 0;
		mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
	}
}

static void send_audio_mrr(uint32_t last_packet, uint8_t radio_packet_prefix, uint16_t pkt_cnt, uint32_t radio_data0, uint32_t radio_data1){
	// Sends 192 bit packet, of which 96b is actual data
	// MRR REG_9: reserved for header
	// MRR REG_A: reserved for header
	// MRR REG_B: reserved for header
	// MRR REG_C: reserved for header
	// MRR REG_D: DATA[23:0]
	// MRR REG_E: DATA[47:24]
	// MRR REG_F: DATA[71:48]
	// MRR REG_10: DATA[95:72]
	
	// CRC16 Encoding 
    uint32_t* output_data;
	
    //output_data = crcEnc16(((radio_packet_count & 0xFF)<<8) | radio_packet_prefix, (radio_data_2 <<16) | ((radio_data_1 & 0xFFFFFF) >>8), (radio_data_1 << 24) | (radio_data_0 & 0xFFFFFF));
	output_data = crcEnc16((((pkt_cnt&0xFF0)<<4)|((radio_packet_prefix&0xF)<<4)|(pkt_cnt&0xF)), radio_data0, radio_data1);
	
    mbus_remote_register_write(MRR_ADDR,0xD,(radio_data1 & 0xFFFFFF));
    mbus_remote_register_write(MRR_ADDR,0xE,((radio_data0 << 8) | (radio_data1 >> 24)));
	mbus_remote_register_write(MRR_ADDR,0xF,((radio_packet_prefix<<20)|((pkt_cnt&0xF)<<16) | (radio_data0 >> 16)));
	mbus_remote_register_write(MRR_ADDR,0x10,((output_data[2] & 0xFFFF)/*CRC16*/<<8) | (pkt_cnt>>4));
	
    if (!radio_ready){
		radio_ready = 1;
		
		// Release FSM Reset
		mrrv10_r11.MRR_RAD_FSM_RSTN = 1;  //UNRST BB
		mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
		delay(MBUS_DELAY);
		
    	mrrv10_r03.MRR_TRX_ISOLATEN = 1;     //set ISOLATEN 1, let state machine control
    	mbus_remote_register_write(MRR_ADDR,0x03,mrrv10_r03.as_int);
		delay(MBUS_DELAY);
		
	}
	
	// Current Limter set-up 
	mrrv10_r00.MRR_CL_CTRL = 1; //Set CL 1: unlimited, 8: 30uA, 16: 3uA
	mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
	uint32_t count = 0;
	uint32_t mrr_cfo_val_fine = 0;
	uint32_t num_packets = 1;
	if (mrr_freq_hopping) num_packets = mrr_freq_hopping;
	
	// New for mrrv10
	mrr_cfo_val_fine = mrr_cfo_val_fine_min;
	
	while (count < num_packets){
		#ifdef DEBUG_MBUS_MSG
			//mbus_write_message32(0xCE, mrr_cfo_val_fine);
		#endif
		
		mrrv10_r01.MRR_TRX_CAP_ANTP_TUNE_FINE = mrr_cfo_val_fine; 
		mrrv10_r01.MRR_TRX_CAP_ANTN_TUNE_FINE = mrr_cfo_val_fine;
		mbus_remote_register_write(MRR_ADDR,0x01,mrrv10_r01.as_int);
		send_radio_data_mrr_sub1();
		count++;
		if (count < num_packets){
			delay(RADIO_PACKET_DELAY);
		}
		mrr_cfo_val_fine = mrr_cfo_val_fine + mrr_freq_hopping_step; // 1: 0.8MHz, 2: 1.6MHz step
	}
	
	radio_packet_count++;
	
	if (last_packet){
		radio_ready = 0;
		radio_power_off();
		}else{
		mrrv10_r11.MRR_RAD_FSM_EN = 0;
		mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
	}
}

static void mrr_init(void) {
	
	// Reqruied in MRRv10 to run like MRRv7
	mrrv10_r21.MRR_TRX_ENb_CONT_RC = 0;  //RX_Decap P 
	mbus_remote_register_write(MRR_ADDR,0x21,mrrv10_r21.as_int);
	
	// Decap in series
	mrrv10_r03.MRR_DCP_P_OW = 0;  //RX_Decap P 
	mbus_remote_register_write(MRR_ADDR,3,mrrv10_r03.as_int);
	mrrv10_r03.MRR_DCP_S_OW = 1;  //TX_Decap S (forced charge decaps)
	mbus_remote_register_write(MRR_ADDR,3,mrrv10_r03.as_int);
	
	// Current Limter set-up 
	mrrv10_r00.MRR_CL_CTRL = 8; //Set CL 1: unlimited, 8: 30uA, 16: 3uA
	mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
    // Turn on Current Limter
    mrrv10_r00.MRR_CL_EN = 1;  //Enable CL
    mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	
	// Wait for charging decap
   	config_timerwd(TIMERWD_VAL);
	*REG_MBUS_WD = 1500000*3; // default: 1500000
	delay(MBUS_DELAY*200); // Wait for decap to charge
	
	mrrv10_r1F.LC_CLK_RING = 0x3;  // ~ 150 kHz
	mrrv10_r1F.LC_CLK_DIV = 0x3;  // ~ 150 kHz
	mbus_remote_register_write(MRR_ADDR,0x1F,mrrv10_r1F.as_int);
	
	//mrr_configure_pulse_width_short();
	mrr_configure_pulse_width_long();
	
	mrr_freq_hopping = 3;
	mrr_freq_hopping_step = 2;
	
	mrr_cfo_val_fine_min = 0x0;
	
	// RO setup (SFO)
	// Adjust Diffusion R
	mbus_remote_register_write(MRR_ADDR,0x06,0x1000); // RO_PDIFF
	
	// Adjust Poly R
	mbus_remote_register_write(MRR_ADDR,0x08,0x400000); // RO_POLY
	
	// Adjust C
	mrrv10_r07.RO_MOM = 0x10;
	mrrv10_r07.RO_MIM = 0x10;
	mbus_remote_register_write(MRR_ADDR,0x07,mrrv10_r07.as_int);
	
	// TX Setup Carrier Freq
	mrrv10_r00.MRR_TRX_CAP_ANTP_TUNE_COARSE = 0x0;  //ANT CAP 10b unary 830.5 MHz
	mbus_remote_register_write(MRR_ADDR,0x00,mrrv10_r00.as_int);
	mrrv10_r01.MRR_TRX_CAP_ANTN_TUNE_COARSE = 0x0; //ANT CAP 10b unary 830.5 MHz
	mrrv10_r01.MRR_TRX_CAP_ANTP_TUNE_FINE = mrr_cfo_val_fine_min;  //ANT CAP 14b unary 830.5 MHz
	mrrv10_r01.MRR_TRX_CAP_ANTN_TUNE_FINE = mrr_cfo_val_fine_min; //ANT CAP 14b unary 830.5 MHz
	mbus_remote_register_write(MRR_ADDR,0x01,mrrv10_r01.as_int);
	mrrv10_r02.MRR_TX_BIAS_TUNE = 0x7FF;  //Set TX BIAS TUNE 13b // Max 0x1FFF
	mbus_remote_register_write(MRR_ADDR,0x02,mrrv10_r02.as_int);
	
	// Turn off RX mode
    mrrv10_r03.MRR_TRX_MODE_EN = 0; //Set TRX mode
	mbus_remote_register_write(MRR_ADDR,3,mrrv10_r03.as_int);
	
    mrrv10_r14.MRR_RAD_FSM_TX_POWERON_LEN = 0; //3bits
	mrrv10_r15.MRR_RAD_FSM_RX_HDR_BITS = 0x00;  //Set RX header
	mrrv10_r15.MRR_RAD_FSM_RX_HDR_TH = 0x00;    //Set RX header threshold
	mrrv10_r15.MRR_RAD_FSM_RX_DATA_BITS = 0x00; //Set RX data 1b
	mbus_remote_register_write(MRR_ADDR,0x14,mrrv10_r14.as_int);
	mbus_remote_register_write(MRR_ADDR,0x15,mrrv10_r15.as_int);
	
	// RAD_FSM set-up 
	// Using first 48 bits of data as header
	mbus_remote_register_write(MRR_ADDR,0x09,0x0);
	mbus_remote_register_write(MRR_ADDR,0x0A,0x0);
	mbus_remote_register_write(MRR_ADDR,0x0B,0x0);
	mbus_remote_register_write(MRR_ADDR,0x0C,0x7AC800);
	mrrv10_r11.MRR_RAD_FSM_TX_H_LEN = 0; //31-31b header (max)
	mrrv10_r11.MRR_RAD_FSM_TX_D_LEN = RADIO_DATA_LENGTH; //0-skip tx data
	mbus_remote_register_write(MRR_ADDR,0x11,mrrv10_r11.as_int);
	
	mrrv10_r13.MRR_RAD_FSM_TX_MODE = 3; //code rate 0:4 1:3 2:2 3:1(baseline) 4:1/2 5:1/3 6:1/4
	mbus_remote_register_write(MRR_ADDR,0x13,mrrv10_r13.as_int);
	
    mrrv10_r04.LDO_SEL_VOUT = 0; // New for MRRv10
    mbus_remote_register_write(MRR_ADDR,0x04,mrrv10_r04.as_int);
	// Mbus return address
	mbus_remote_register_write(MRR_ADDR,0x1E,0x1002);
	
	// Additional delay for charging decap
   	config_timerwd(TIMERWD_VAL);
	*REG_MBUS_WD = 1500000; // default: 1500000
	delay(MBUS_DELAY*200); // Wait for decap to charge
}

	
//*******************************************************************
// XO Functions
//*******************************************************************

static void XO_init(void) {
    // Parasitic Capacitance Tuning (6-bit for each; Each 1 adds 1.8pF)
    uint32_t xo_cap_drv = 0x3F;//0x3F; // Additional Cap on OSC_DRV
    uint32_t xo_cap_in  = 0x3F;//0x3F; // Additional Cap on OSC_IN
    prev20_r1A.XO_CAP_TUNE = (
            (xo_cap_drv <<6) | 
            (xo_cap_in <<0));   // XO_CLK Output Pad 
    *REG_XO_CONF2 = prev20_r1A.as_int;

    // XO configuration
    prev20_r19.XO_EN_DIV    = 0x1;// divider enable
    prev20_r19.XO_S         = 0x1;// division ratio for 16kHz out
    prev20_r19.XO_SEL_CP_DIV= 0x0;// 1: 0.3V-generation charge-pump uses divided clock
    prev20_r19.XO_EN_OUT    = 0x1;// XO ouput enable
    prev20_r19.XO_PULSE_SEL = 0x8;//4;// pulse width sel, 1-hot code
    prev20_r19.XO_DELAY_EN  = 0x7;//3;// pair usage together with xo_pulse_sel
    prev20_r19.XO_SLEEP = 0x0;
    // Pseudo-Resistor Selection
    prev20_r19.XO_RP_LOW    = 0x0;//0  1
    prev20_r19.XO_RP_MEDIA  = 0x1;//1  0
    prev20_r19.XO_RP_MVT    = 0x0;//0
    prev20_r19.XO_RP_SVT    = 0x0;//0
    *REG_XO_CONF1 = prev20_r19.as_int;
    delay(1000);
    prev20_r19.XO_ISOLATE = 0x0;
    *REG_XO_CONF1 = prev20_r19.as_int;
    delay(1000);
    prev20_r19.XO_DRV_START_UP  = 0x1;// 1: enables start-up circuit
    *REG_XO_CONF1 = prev20_r19.as_int;
    delay(2000);
    //// after start-up, turn on core circuit and turn off start-up circuit
//    prev20_r19.XO_SCN_CLK_SEL   = 0x1;// scn clock 1: normal. 0.3V level up to 0.6V, 0:init
//    *REG_XO_CONF1 = prev20_r19.as_int;
//    delay(2000);
//    prev20_r19.XO_SCN_CLK_SEL   = 0x0;
//    prev20_r19.XO_SCN_ENB       = 0x0;// enable_bar of scn
//    *REG_XO_CONF1 = prev20_r19.as_int;
//    delay(2000);
//    prev20_r19.XO_DRV_START_UP  = 0x0;
//    prev20_r19.XO_DRV_CORE      = 0x1;// 1: enables core circuit
//    prev20_r19.XO_SCN_CLK_SEL   = 0x1;
//    *REG_XO_CONF1 = prev20_r19.as_int;
//    delay(2000);

    enable_xo_timer();
    start_xo_cout();
    
#ifdef DEBUG_MBUS_MSG
    mbus_write_message32(0xE3,0x00000E2D); 
#endif    
}

//************************************
// GPIO Functions
// ***********************************
static void init_gpio(void){
    gpio_set_dir (direction_gpio);  // input:0, output:1
    gpio_write_current_data();
    set_gpio_pad (0xFF); // 0xFF activate all 8 GPIO bits
    unfreeze_gpio_out();
}



//************************************
// PMU Related Functions
//************************************
static void pmu_set_sar_override(uint32_t val){
    // SAR_RATIO_OVERRIDE
    mbus_remote_register_write(PMU_ADDR,0x05, //default 12'h000
		( (0 << 13) // Enables override setting [12] (1'b1)
			| (0 << 12) // Let VDD_CLK always connected to vbat
			| (1 << 11) // Enable override setting [10] (1'h0)
			| (0 << 10) // Have the converter have the periodic reset (1'h0)
			| (1 << 9) // Enable override setting [8] (1'h0)
			| (0 << 8) // Switch input / output power rails for upconversion (1'h0)
			| (1 << 7) // Enable override setting [6:0] (1'h0)
			| (val)       // Binary converter's conversion ratio (7'h00)
		));
		delay(MBUS_DELAY*2);
		mbus_remote_register_write(PMU_ADDR,0x05, //default 12'h000
            ( (1 << 13) // Enables override setting [12] (1'b1)
				| (0 << 12) // Let VDD_CLK always connected to vbat
				| (1 << 11) // Enable override setting [10] (1'h0)
				| (0 << 10) // Have the converter have the periodic reset (1'h0)
				| (1 << 9) // Enable override setting [8] (1'h0)
				| (0 << 8) // Switch input / output power rails for upconversion (1'h0)
				| (1 << 7) // Enable override setting [6:0] (1'h0)
				| (val)       // Binary converter's conversion ratio (7'h00)
			));
			delay(MBUS_DELAY*2);
}


inline static void pmu_set_adc_period(uint32_t val){
    // PMU_CONTROLLER_DESIRED_STATE Active
    mbus_remote_register_write(PMU_ADDR,0x3C,
		((  1 << 0) //state_sar_scn_on
			| (0 << 1) //state_wait_for_clock_cycles
			| (1 << 2) //state_wait_for_time
			| (1 << 3) //state_sar_scn_reset
			| (1 << 4) //state_sar_scn_stabilized
			| (1 << 5) //state_sar_scn_ratio_roughly_adjusted
			| (1 << 6) //state_clock_supply_switched
			| (1 << 7) //state_control_supply_switched
			| (1 << 8) //state_upconverter_on
			| (1 << 9) //state_upconverter_stabilized
			| (1 << 10) //state_refgen_on
			| (0 << 11) //state_adc_output_ready
			| (0 << 12) //state_adc_adjusted
			| (0 << 13) //state_sar_scn_ratio_adjusted
			| (1 << 14) //state_downconverter_on
			| (1 << 15) //state_downconverter_stabilized
			| (1 << 16) //state_vdd_3p6_turned_on
			| (1 << 17) //state_vdd_1p2_turned_on
			| (1 << 18) //state_vdd_0P6_turned_on
			| (1 << 19) //state_state_horizon
		));
		delay(MBUS_DELAY*10);
		
		// Register 0x36: TICK_REPEAT_VBAT_ADJUST
		mbus_remote_register_write(PMU_ADDR,0x36,val); 
		delay(MBUS_DELAY*10);
		
		// Register 0x33: TICK_ADC_RESET
		mbus_remote_register_write(PMU_ADDR,0x33,2);
		delay(MBUS_DELAY);
		
		// Register 0x34: TICK_ADC_CLK
		mbus_remote_register_write(PMU_ADDR,0x34,2);
		delay(MBUS_DELAY);
		
		// PMU_CONTROLLER_DESIRED_STATE Active
		mbus_remote_register_write(PMU_ADDR,0x3C,
            ((  1 << 0) //state_sar_scn_on
				| (1 << 1) //state_wait_for_clock_cycles
				| (1 << 2) //state_wait_for_time
				| (1 << 3) //state_sar_scn_reset
				| (1 << 4) //state_sar_scn_stabilized
				| (1 << 5) //state_sar_scn_ratio_roughly_adjusted
				| (1 << 6) //state_clock_supply_switched
				| (1 << 7) //state_control_supply_switched
				| (1 << 8) //state_upconverter_on
				| (1 << 9) //state_upconverter_stabilized
				| (1 << 10) //state_refgen_on
				| (0 << 11) //state_adc_output_ready
				| (0 << 12) //state_adc_adjusted
				| (0 << 13) //state_sar_scn_ratio_adjusted
				| (1 << 14) //state_downconverter_on
				| (1 << 15) //state_downconverter_stabilized
				| (1 << 16) //state_vdd_3p6_turned_on
				| (1 << 17) //state_vdd_1p2_turned_on
				| (1 << 18) //state_vdd_0P6_turned_on
				| (1 << 19) //state_state_horizon
			));
			delay(MBUS_DELAY);
}


inline static void pmu_set_active_clk(uint8_t r, uint8_t l, uint8_t base, uint8_t l_1p2){
	
    // The first register write to PMU needs to be repeated
    // Register 0x16: V1P2 Active
    mbus_remote_register_write(PMU_ADDR,0x16, 
		( (0 << 19) // Enable PFM even during periodic reset
			| (0 << 18) // Enable PFM even when Vref is not used as ref
			| (0 << 17) // Enable PFM
			| (3 << 14) // Comparator clock division ratio
			| (0 << 13) // Enable main feedback loop
			| (r << 9)  // Frequency multiplier R
			| (l_1p2 << 5)  // Frequency multiplier L (actually L+1)
			| (base)      // Floor frequency base (0-63)
		));
		delay(MBUS_DELAY);
		mbus_remote_register_write(PMU_ADDR,0x16, 
            ( (0 << 19) // Enable PFM even during periodic reset
				| (0 << 18) // Enable PFM even when Vref is not used as ref
				| (0 << 17) // Enable PFM
				| (3 << 14) // Comparator clock division ratio
				| (0 << 13) // Enable main feedback loop
				| (r << 9)  // Frequency multiplier R
				| (l_1p2 << 5)  // Frequency multiplier L (actually L+1)
				| (base)      // Floor frequency base (0-63)
			));
			delay(MBUS_DELAY);
			// Register 0x18: V3P6 Active 
			mbus_remote_register_write(PMU_ADDR,0x18, 
				( (3 << 14) // Desired Vout/Vin ratio; defualt: 0
					| (0 << 13) // Enable main feedback loop
					| (r << 9)  // Frequency multiplier R
					| (l << 5)  // Frequency multiplier L (actually L+1)
					| (base)      // Floor frequency base (0-63)
				));
				delay(MBUS_DELAY);
				// Register 0x1A: V0P6 Active
				mbus_remote_register_write(PMU_ADDR,0x1A,
					( (0 << 13) // Enable main feedback loop
						| (r << 9)  // Frequency multiplier R
						| (l << 5)  // Frequency multiplier L (actually L+1)
						| (base)      // Floor frequency base (0-63)
					));
					delay(MBUS_DELAY);
					
}

inline static void pmu_set_sleep_clk(uint8_t r, uint8_t l, uint8_t base, uint8_t l_1p2){
	
    // Register 0x17: V3P6 Sleep
    mbus_remote_register_write(PMU_ADDR,0x17, 
		( (3 << 14) // Desired Vout/Vin ratio; defualt: 0
			| (0 << 13) // Enable main feedback loop
			| (r << 9)  // Frequency multiplier R
			| (l << 5)  // Frequency multiplier L (actually L+1)
			| (base)      // Floor frequency base (0-63)
		));
		
		//mbus_remote_register_write(PMU_ADDR,0x17, 
		//        ( (3 << 14) // Desired Vout/Vin ratio; defualt: 0
		//          | (0 << 13) // Enable main feedback loop
		//          | (1 << 9)  // Frequency multiplier R
		//          | (0 << 5)  // Frequency multiplier L (actually L+1)
		//          | (8)         // Floor frequency base (0-63)
		//        ));
		delay(MBUS_DELAY);
		// Register 0x15: V1P2 Sleep
		mbus_remote_register_write(PMU_ADDR,0x15, 
            ( (0 << 19) // Enable PFM even during periodic reset
				| (0 << 18) // Enable PFM even when Vref is not used as ref
				| (0 << 17) // Enable PFM
				| (3 << 14) // Comparator clock division ratio
				| (0 << 13) // Enable main feedback loop
				| (r << 9)  // Frequency multiplier R
				| (l_1p2 << 5)  // Frequency multiplier L (actually L+1)
				| (base)      // Floor frequency base (0-63)
			));
			delay(MBUS_DELAY);
			// Register 0x19: V0P6 Sleep
			mbus_remote_register_write(PMU_ADDR,0x19,
				( (0 << 13) // Enable main feedback loop
					| (r << 9)  // Frequency multiplier R
					| (l << 5)  // Frequency multiplier L (actually L+1)
					| (base)      // Floor frequency base (0-63)
				));
				delay(MBUS_DELAY);
}

inline static void pmu_set_clk_init(){
    //pmu_set_sar_override(0x4A);
    //pmu_set_active_clk(0xA,0x4,0x10,0x4);
    //pmu_set_sleep_clk(0xA,0x4,0x10,0x4); //with TEST1P2
    //pmu_set_sar_override(0x5A);
    pmu_set_active_clk(0xA,0x1,0x10,0x2); //-10C test
    pmu_set_sleep_clk(0xA,0x1,0x10,0x4); //with TEST1P2
    //pmu_set_active_clk(0xF,0xF,0x1F,0xF); //-10C test
    //pmu_set_sleep_clk(0xF,0xF,0x1F,0xF); //with TEST1P2
    // SAR_RATIO_OVERRIDE
    // Use the new reset scheme in PMUv3
    mbus_remote_register_write(PMU_ADDR,0x05, //default 12'h000
		( (0 << 13) // Enables override setting [12] (1'b1)
			| (0 << 12) // Let VDD_CLK always connected to vbat
			| (1 << 11) // Enable override setting [10] (1'h0)
			| (0 << 10) // Have the converter have the periodic reset (1'h0)
			| (0 << 9) // Enable override setting [8] (1'h0)
			| (0 << 8) // Switch input / output power rails for upconversion (1'h0)
			| (0 << 7) // Enable override setting [6:0] (1'h0)
			| (0x45)      // Binary converter's conversion ratio (7'h00)
		));
		delay(MBUS_DELAY);
		pmu_set_sar_override(pmu_sar_conv_ratio_val_test_on);
		//pmu_set_sar_override(0x4A);
		//  pmu_set_sar_override(0x4D);
		//  pmu_set_sar_override(0x2D);
		//  pmu_set_sar_override(0x29);
		
		pmu_set_adc_period(1); // 0x100 about 1 min for 1/2/1 1P2 setting
}

inline static void pmu_adc_reset_setting(){
    // PMU ADC will be automatically reset when system wakes up
    // PMU_CONTROLLER_DESIRED_STATE Active
    mbus_remote_register_write(PMU_ADDR,0x3C,
		((  1 << 0) //state_sar_scn_on
			| (1 << 1) //state_wait_for_clock_cycles
			| (1 << 2) //state_wait_for_time
			| (1 << 3) //state_sar_scn_reset
			| (1 << 4) //state_sar_scn_stabilized
			| (1 << 5) //state_sar_scn_ratio_roughly_adjusted
			| (1 << 6) //state_clock_supply_switched
			| (1 << 7) //state_control_supply_switched
			| (1 << 8) //state_upconverter_on
			| (1 << 9) //state_upconverter_stabilized
			| (1 << 10) //state_refgen_on
			| (0 << 11) //state_adc_output_ready
			| (0 << 12) //state_adc_adjusted
			| (0 << 13) //state_sar_scn_ratio_adjusted
			| (1 << 14) //state_downconverter_on
			| (1 << 15) //state_downconverter_stabilized
			| (1 << 16) //state_vdd_3p6_turned_on
			| (1 << 17) //state_vdd_1p2_turned_on
			| (1 << 18) //state_vdd_0P6_turned_on
			| (1 << 19) //state_state_horizon
		));
		delay(MBUS_DELAY);
}


inline static void pmu_adc_disable(){
    // PMU ADC will be automatically reset when system wakes up
    // PMU_CONTROLLER_DESIRED_STATE Sleep
    mbus_remote_register_write(PMU_ADDR,0x3B,
		((  1 << 0) //state_sar_scn_on
			| (1 << 1) //state_wait_for_clock_cycles
			| (1 << 2) //state_wait_for_time
			| (1 << 3) //state_sar_scn_reset
			| (1 << 4) //state_sar_scn_stabilized
			| (1 << 5) //state_sar_scn_ratio_roughly_adjusted
			| (1 << 6) //state_clock_supply_switched
			| (1 << 7) //state_control_supply_switched
			| (1 << 8) //state_upconverter_on
			| (1 << 9) //state_upconverter_stabilized
			| (1 << 10) //state_refgen_on
			| (0 << 11) //state_adc_output_ready
			| (0 << 12) //state_adc_adjusted
			| (0 << 13) //state_sar_scn_ratio_adjusted
			| (1 << 14) //state_downconverter_on
			| (1 << 15) //state_downconverter_stabilized
			| (1 << 16) //state_vdd_3p6_turned_on
			| (1 << 17) //state_vdd_1p2_turned_on
			| (1 << 18) //state_vdd_0P6_turned_on
			| (0 << 19) //state_vbat_readonly
			| (1 << 20) //state_state_horizon
		));
		delay(MBUS_DELAY);
}

inline static void pmu_adc_enable(){
    // PMU ADC will be automatically reset when system wakes up
    // PMU_CONTROLLER_DESIRED_STATE Sleep
    mbus_remote_register_write(PMU_ADDR,0x3B,
		((  1 << 0) //state_sar_scn_on
			| (1 << 1) //state_wait_for_clock_cycles
			| (1 << 2) //state_wait_for_time
			| (1 << 3) //state_sar_scn_reset
			| (1 << 4) //state_sar_scn_stabilized
			| (1 << 5) //state_sar_scn_ratio_roughly_adjusted
			| (1 << 6) //state_clock_supply_switched
			| (1 << 7) //state_control_supply_switched
			| (1 << 8) //state_upconverter_on
			| (1 << 9) //state_upconverter_stabilized
			| (1 << 10) //state_refgen_on
			| (1 << 11) //state_adc_output_ready
			| (0 << 12) //state_adc_adjusted // Turning off offset cancellation
			| (1 << 13) //state_sar_scn_ratio_adjusted
			| (1 << 14) //state_downconverter_on
			| (1 << 15) //state_downconverter_stabilized
			| (1 << 16) //state_vdd_3p6_turned_on
			| (1 << 17) //state_vdd_1p2_turned_on
			| (1 << 18) //state_vdd_0P6_turned_on
			| (1 << 19) //state_state_horizon
		));
		delay(MBUS_DELAY);
}

//inline static void pmu_adc_read_latest(){
//
//    // Grab latest PMU ADC readings
//    // PMU register read is handled differently
//    mbus_remote_register_write(PMU_ADDR,0x00,0x03);
//    delay(MBUS_DELAY);
//    read_data_batadc = *((volatile uint32_t *) REG0) & 0xFF;
//
//}

inline static void pmu_reset_solar_short(){
    mbus_remote_register_write(PMU_ADDR,0x0E, 
		( (1 << 10) // When to turn on harvester-inhibiting switch (0: PoR, 1: VBAT high)
			| (1 << 9)  // Enables override setting [8]
			| (0 << 8)  // Turn on the harvester-inhibiting switch
			| (1 << 4)  // clamp_tune_bottom (increases clamp thresh)
			| (0)         // clamp_tune_top (decreases clamp thresh)
		));
		delay(MBUS_DELAY);
		mbus_remote_register_write(PMU_ADDR,0x0E, 
            ( (1 << 10) // When to turn on harvester-inhibiting switch (0: PoR, 1: VBAT high)
				| (0 << 9)  // Enables override setting [8]
				| (0 << 8)  // Turn on the harvester-inhibiting switch
				| (1 << 4)  // clamp_tune_bottom (increases clamp thresh)
				| (0)         // clamp_tune_top (decreases clamp thresh)
			));
			delay(MBUS_DELAY);
}

//***************************************************
//  FLP functions
//***************************************************

static void flp_fail(uint32_t id)
{
	delay(10000);
	mbus_write_message32(0xE2, 0xDEADBEEF);
	delay(10000);
	mbus_write_message32(0xE2, id);
	delay(10000);
	mbus_write_message32(0xE2, 0xDEADBEEF);
	delay(10000);
	mbus_sleep_all();
	while(1);
}


static void FLASH_initialization (void) {
    
    // Tune Flash
    mbus_remote_register_write (FLP1_ADDR , 0x00 , 0xF84001); // T5us, T10us setting for ~100kHz CLKmain
    mbus_remote_register_write (FLP1_ADDR , 0x01 , 0x00AF01); // Tcyc_prog, Tprog setting for ~100kHz CLKmain
    mbus_remote_register_write (FLP1_ADDR , 0x26 , 0x0D7788); // Program Current: Default
    mbus_remote_register_write (FLP1_ADDR , 0x27 , 0x011BC8); // Erase Pump Diode Chain: Default
    mbus_remote_register_write (FLP1_ADDR , 0x01 , 0x007F09); // Tprog idle time: Default
    mbus_remote_register_write (FLP1_ADDR , 0x19 , 0x000F86); // Voltage Clamper Tuning: 1STG-0xF, 2STG-max, VOUT-0x6
    mbus_remote_register_write (FLP1_ADDR , 0x0F , 0x001001); // Flash interrupt target register addr: REG0 -> REG1
    //mbus_remote_register_write (FLP1_ADDR , 0x12 , 0x000003); // Auto Power On/Off
    mbus_remote_register_write (FLP1_ADDR , 0x18 , 0x00002F); // CLK_RING_SEL: 4'hF, CLK_DIV_SEL: 2'h2 -> ~200kHz
	
}


static void FLASH_turn_on()
{
    set_halt_until_mbus_rx();
    mbus_remote_register_write (FLP1_ADDR , 0x11 , 0x00002F);
    set_halt_until_mbus_tx();
	
    if (*REG1 != 0xB5) flp_fail (0);
}

static void FLASH_turn_off()
{
    set_halt_until_mbus_rx();
    mbus_remote_register_write (FLP1_ADDR , 0x11 , 0x00002D);
    set_halt_until_mbus_tx();
	
    if (*REG1 != 0xBB) flp_fail (1);
}

static void FLASH_pp_ready (void) {
	
	// Erase Flash
	uint32_t page_start_addr = 0;
	uint32_t idx;
	
	for (idx=0; idx<1024; idx++){ // All Pages (8Mb) are erased.
		page_start_addr = (idx << 8);
		
		mbus_remote_register_write (FLP1_ADDR, 0x08, page_start_addr); // Set FLSH_START_ADDR
		
		set_halt_until_mbus_rx();
		mbus_remote_register_write (FLP1_ADDR, 0x09, 0x000029); // Page Erase
		set_halt_until_mbus_tx();
		
		if (*REG1 != 0x00004F) flp_fail((0xFFFF << 16) | idx);
	}
    
    // Ping Pong Setting
	mbus_remote_register_write (FLP1_ADDR, 0x13 , 0x000001); // Enable Ping Pong w/ No length limit
	mbus_remote_register_write (FLP1_ADDR, 0x14 , 0x00001B); // Over run err no detection & fast programming & no wrapping & DATA0/DATA1 enable
	mbus_remote_register_write (FLP1_ADDR, 0x15 , 0x000000); // Flash program addr started from 0x0
	
}

static void FLASH_pp_on (void) {
    mbus_remote_register_write (FLP1_ADDR, 0x09, 0x00002D); // Ping Pong Go
}

static void FLASH_pp_off (void) {
    set_halt_until_mbus_rx();
    mbus_remote_register_write (FLP1_ADDR, 0x13, 0x000000); // Ping Pong End
    set_halt_until_mbus_tx();
}

static void FLASH_read_8k (void) {
    uint32_t i;
    uint32_t j;
    uint32_t flp_sram_addr;
    flp_sram_addr = 0;
    FLASH_turn_on();
	
	
    // Flash Read
    mbus_remote_register_write (FLP1_ADDR, 0x08 , 0x0); // Set FLSH_START_ADDR
    mbus_remote_register_write (FLP1_ADDR, 0x07 , 0x0); // Set SRAM_START_ADDR
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x0; //disable watchdog for long access
	*REG_MBUS_WD = prev20_r1F.as_int;
	
    set_halt_until_mbus_rx();
    mbus_remote_register_write (FLP1_ADDR, 0x09 , 0x07FFE3); // Flash -> SRAM
    set_halt_until_mbus_tx();
	
    if (*REG1 != 0x00002B) flp_fail(4);
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x16E360; //set watchdog back to default
	*REG_MBUS_WD = prev20_r1F.as_int;
	
    //for(j=0; j<81; j++){
    for(j=0; j<64; j++){
	set_halt_until_mbus_rx();
	mbus_copy_mem_from_remote_to_any_bulk (FLP1_ADDR, (uint32_t *) flp_sram_addr, 0x1, read_data, 127);
	set_halt_until_mbus_tx();
	delay(100);
	for (i=0; i<128; i++) {
		mbus_write_message32(0xC0, read_data[i]);
	}
        flp_sram_addr = flp_sram_addr + 512;
		mbus_write_message32(0xDD, j);
	}

// Turn off Flash
FLASH_turn_off();
}
/*
static void FLASH_read_short (void) {
    uint32_t i;
    uint32_t j;
    uint32_t flp_sram_addr;
    flp_sram_addr = 0;
    FLASH_turn_on();
	
	
    // Flash Read
    mbus_remote_register_write (FLP1_ADDR, 0x08 , 0x0); // Set FLSH_START_ADDR
    mbus_remote_register_write (FLP1_ADDR, 0x07 , 0x0); // Set SRAM_START_ADDR
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x0; //disable watchdog for long access
	*REG_MBUS_WD = prev20_r1F.as_int;
	
    set_halt_until_mbus_rx();
    mbus_remote_register_write (FLP1_ADDR, 0x09 , 0x04AAA3); // Flash -> SRAM, 2730 words
    set_halt_until_mbus_tx();
	
    if (*REG1 != 0x00002B) flp_fail(4);
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x16E360; //set watchdog back to default
	*REG_MBUS_WD = prev20_r1F.as_int;
	
    //for(j=0; j<81; j++){
    for(j=0; j<22; j++){
		set_halt_until_mbus_rx();
		mbus_copy_mem_from_remote_to_any_bulk (FLP1_ADDR, (uint32_t *) flp_sram_addr, 0x1, read_data, 127);
		set_halt_until_mbus_tx();
		delay(100);
		for (i=0; i<128; i++) {
			mbus_write_message32(0xC0, read_data[i]);
		}
        flp_sram_addr = flp_sram_addr + 512;
		mbus_write_message32(0xDD, j);
	}

// Turn off Flash
FLASH_turn_off();
}
*/
	
static void FLASH_read_8M (void) {
    uint32_t i;
	uint32_t k;
    uint32_t j;
    uint32_t flp_sram_addr;
    flp_sram_addr = 0;
    FLASH_turn_on();
	
    // Flash Read
	for (k=0; k<6; k++){ //not 8M right now - make this 1024 for 8M
		mbus_remote_register_write (FLP1_ADDR, 0x08 , k*8192); // Set FLSH_START_ADDR
		mbus_remote_register_write (FLP1_ADDR, 0x07 , 0x0); // Set SRAM_START_ADDR
	
		prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x0; //disable watchdog for long access
		*REG_MBUS_WD = prev20_r1F.as_int;
	
		set_halt_until_mbus_rx();
		mbus_remote_register_write (FLP1_ADDR, 0x09 , 0x07FFE3); // Flash -> SRAM
		set_halt_until_mbus_tx();
	
		if (*REG1 != 0x00002B) flp_fail(4);
		
		prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x16E360; //set watchdog back to default
		*REG_MBUS_WD = prev20_r1F.as_int;
		
		flp_sram_addr = 0;
		
		for(j=0; j<64; j++){
			set_halt_until_mbus_rx();
			mbus_copy_mem_from_remote_to_any_bulk (FLP1_ADDR, (uint32_t *) flp_sram_addr, 0x1, read_data, 127);
			set_halt_until_mbus_tx();
			delay(100);
			for (i=0; i<128; i++) {
				mbus_write_message32(0xC0, read_data[i]);
			}
			flp_sram_addr = flp_sram_addr + 512;
			mbus_write_message32(0xDD, j);
		}
	}
	// Turn off Flash
	FLASH_turn_off();

}

void flpv3l_sram_write_all(uint32_t data_type) {
    uint32_t pattern = 0x00000000;
    uint32_t idx_i;

    FLASH_turn_on();
	
    // Choose Data Pattern
    if      (data_type == 0) pattern = 0x00000000;
    else if (data_type == 1) pattern = 0xFFFFFFFF;
    else if (data_type == 2) pattern = 0xAAAAAAAA;
    else if (data_type == 3) pattern = 0x55555555;

    // Initialize temp_storage
    for (idx_i=0; idx_i<_SIZE_TEMP_; idx_i++) temp_storage[idx_i] = pattern;

    // Write into SRAM
    for (idx_i=0; idx_i<_ITER_TEMP_; idx_i++) {
        uint32_t dest_mem_addr = (idx_i << (_LOG2_TEMP_ + 2));
        mbus_copy_mem_from_local_to_remote_bulk(FLP1_ADDR, (uint32_t *) dest_mem_addr, temp_storage, (_SIZE_TEMP_ - 1));
    }

    FLASH_turn_off();
}

static void FLASH_prog_8k (void) {

    FLASH_turn_on();
	
    // Flash prog
    mbus_remote_register_write (FLP1_ADDR, 0x08 , 0x0); // Set FLSH_START_ADDR
    mbus_remote_register_write (FLP1_ADDR, 0x07 , 0x0); // Set SRAM_START_ADDR
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x0; //disable watchdog for long access
	*REG_MBUS_WD = prev20_r1F.as_int;
	
    set_halt_until_mbus_rx();
    mbus_remote_register_write (FLP1_ADDR, 0x09 , 0x07FFE7); // Flash -> SRAM
    set_halt_until_mbus_tx();
	
    if (*REG1 != 0x00005D) flp_fail(4);
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x16E360; //set watchdog back to default
	*REG_MBUS_WD = prev20_r1F.as_int;
	
	// Turn off Flash
	FLASH_turn_off();
}

//***************************************************
//  ADO functions
//***************************************************
static void ado_initialization(void){
    // as_int of all zero regs initalization
    adov6vb_r07.as_int = 0;
    adov6vb_r0B.as_int = 0;
    adov6vb_r10.as_int = 0;

    adov6vb_r10.VAD_ADC_DOUT_ISOL = 1;
    mbus_remote_register_write(ADO_ADDR, 0x10, adov6vb_r10.as_int);
 
    // AFE Initialization
    // adov6vb_r15.VAD_LNA_AMPMOD_EN = 0;
    adov6vb_r15.IB_GEN_CLK_EN = 1;
    adov6vb_r15.LS_CLK_EN_1P2 = 1;
    adov6vb_r15.REC_PGA_BWCON = 32;//24;
    adov6vb_r15.REC_PGA_CFBADD = 1;//0;
    adov6vb_r15.REC_PGA_GCON = 2;//2;
    mbus_remote_register_write(ADO_ADDR, 0x15, adov6vb_r15.as_int); //1F8622

    adov6vb_r16.IBC_MONAMP = 0;
    adov6vb_r16.IBC_REC_LNA = 6;
    adov6vb_r16.IBC_REC_PGA = 11;
    adov6vb_r16.IBC_VAD_LNA = 7;
    adov6vb_r16.IBC_VAD_PGA = 5;
    mbus_remote_register_write(ADO_ADDR, 0x16, adov6vb_r16.as_int);//0535BD
 
    adov6vb_r18.REC_LNA_N1_CON = 2;
    adov6vb_r18.REC_LNA_N2_CON = 2;
    adov6vb_r18.REC_LNA_P1_CON = 3;
    adov6vb_r18.REC_LNA_P2_CON = 3;
    mbus_remote_register_write(ADO_ADDR, 0x18, adov6vb_r18.as_int);//0820C3

    adov6vb_r19.REC_PGA_P1_CON = 3;
    mbus_remote_register_write(ADO_ADDR, 0x19, adov6vb_r19.as_int);//007064

    adov6vb_r1B.VAD_LNA_N1_LCON = 5;
    adov6vb_r1B.VAD_LNA_N2_LCON = 6;
    adov6vb_r1B.VAD_LNA_P1_CON = 3;
    adov6vb_r1B.VAD_LNA_P2_CON = 2;
    mbus_remote_register_write(ADO_ADDR, 0x1B, adov6vb_r1B.as_int);//0A6062

    adov6vb_r1C.VAD_PGA_N1_LCON = 0;
    adov6vb_r1C.VAD_PGA_N1_MCON = 1;
    mbus_remote_register_write(ADO_ADDR, 0x1C, adov6vb_r1C.as_int);//00079C

    adov6vb_r11.LDO_CTRL_VREFLDO_VOUT_1P4HP = 4;
    mbus_remote_register_write(ADO_ADDR, 0x11, adov6vb_r11.as_int);//84CAC9

    adov6vb_r12.LDO_CTRL_VREFLDO_VOUT_0P6LP = 3;
    adov6vb_r12.LDO_CTRL_VREFLDO_VOUT_0P9HP = 3;
    adov6vb_r12.LDO_CTRL_VREFLDO_VOUT_1P4LP = 4;
    mbus_remote_register_write(ADO_ADDR, 0x12, adov6vb_r12.as_int);//828283
    
    /////////////////
    //DSP LP_TOP
    ///////////////////
    //PHS_FE Programming
    mbus_remote_register_write(ADO_ADDR, 0x05, 0x000004); //PHS_DATA_FE
    mbus_remote_register_write(ADO_ADDR, 0x06, 0x000001); //PHS_WR_FE high
    mbus_remote_register_write(ADO_ADDR, 0x06, 0x000000); //PHS_WR_FE low 
    //SD_TH Programming
    mbus_remote_register_write(ADO_ADDR, 0x09, 0x000064); //TH_DATA
    mbus_remote_register_write(ADO_ADDR, 0x0A, 0x000001); //TH_WR high
    mbus_remote_register_write(ADO_ADDR, 0x0A, 0x000000); //TH_WR low
    //LUT Programming
    uint8_t i;
    for(i= 0; i<LUT_DATA_LENGTH; i++){
        adov6vb_r07.DSP_LUT_WR_ADDR = i;
        adov6vb_r07.DSP_LUT_DATA_IN = LUT_DATA[i];
        mbus_remote_register_write(ADO_ADDR, 0x07, adov6vb_r07.as_int);
        mbus_remote_register_write(ADO_ADDR, 0x08, 0x000001);
        mbus_remote_register_write(ADO_ADDR, 0x08, 0x000000);
    }
    //PHS Programming 
    for(i= 0; i<PHS_DATA_LENGTH; i++){
        adov6vb_r0B.DSP_PHS_WR_ADDR_FS = i;
        adov6vb_r0B.DSP_PHS_DATA_IN_FS = PHS_DATA[i];
        mbus_remote_register_write(ADO_ADDR, 0x0B, adov6vb_r0B.as_int);
        mbus_remote_register_write(ADO_ADDR, 0x0C, 0x000001);
        mbus_remote_register_write(ADO_ADDR, 0x0C, 0x000000);
    }
    
    //N_DCT: 128 points DCT 
    adov6vb_r00.DSP_N_DCT = 2; //128-pt DCT
    adov6vb_r00.DSP_N_FFT = 4; //256-pt FFT
    mbus_remote_register_write(ADO_ADDR, 0x00, adov6vb_r00.as_int);
    
    //WAKEUP REQ EN
    adov6vb_r0E.DSP_WAKEUP_REQ_EN = 1;
    mbus_remote_register_write(ADO_ADDR, 0x0E, adov6vb_r0E.as_int);
}
static void digital_set_mode(uint8_t mode){
    if(mode == 1){      //LP DSP

        adov6vb_r0D.DSP_HP_ADO_GO = 0;
        adov6vb_r0D.DSP_HP_DNN_GO = 0;
        adov6vb_r0D.DSP_HP_FIFO_GO = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BCB5
        adov6vb_r0D.DSP_HP_RESETN = 0;
        adov6vb_r0D.DSP_DNN_HP_MODE_EN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC15
        
        adov6vb_r0D.DSP_DNN_RESETN_RF = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC05
        adov6vb_r0D.DSP_DNN_ISOLATEN_RF = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC09
        adov6vb_r0D.DSP_DNN_PG_SLEEP_RF = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC0B
        adov6vb_r0D.DSP_DNN_CTRL_RF_SEL = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC0A
        
        adov6vb_r04.DSP_P2S_RESETN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//E00040
        adov6vb_r04.DSP_P2S_RESETN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//E00040
        
        adov6vb_r0D.DSP_LP_RESETN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC4A
        }
    else if(mode == 2){ // HP DSP
        adov6vb_r0D.DSP_LP_RESETN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80A

        adov6vb_r0D.DSP_DNN_CTRL_RF_SEL = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
        adov6vb_r0D.DSP_DNN_CLKENB_RF_SEL = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
        adov6vb_r0D.DSP_DNN_PG_SLEEP_RF = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B809
        adov6vb_r0D.DSP_DNN_ISOLATEN_RF = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80D
        adov6vb_r0D.DSP_DNN_CLKENB_RF = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B805
        adov6vb_r0D.DSP_DNN_RESETN_RF = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B815
        
        adov6vb_r0D.DSP_DNN_HP_MODE_EN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B835
        
        adov6vb_r0D.DSP_DNN_CLKENB_RF_SEL = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
        
        adov6vb_r04.DSP_P2S_RESETN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//E00040
        adov6vb_r04.DSP_P2S_RESETN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//E00040

        adov6vb_r0D.DSP_HP_RESETN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B8B5
        adov6vb_r0D.DSP_HP_FIFO_GO = 1;
        adov6vb_r0D.DSP_HP_ADO_GO = 1;
        adov6vb_r0D.DSP_HP_DNN_GO = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BBB5
        }
    else if(mode == 3){ // HP Compression only
        adov6vb_r0D.DSP_LP_RESETN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80A
        adov6vb_r04.DSP_P2S_RESETN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//E00040
		adov6vb_r04.DSP_ADO_POWER_TH = 0x000D;
		mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);
		delay(MBUS_DELAY*9);

        adov6vb_r0D.DSP_DNN_CTRL_RF_SEL = 0; //from trex
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
        adov6vb_r0D.DSP_DNN_CLKENB_RF_SEL = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
        //adov6vb_r0D.DSP_DNN_PG_SLEEP_RF = 0;
        //mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B809
        //adov6vb_r0D.DSP_DNN_ISOLATEN_RF = 1;
        //mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80D
        //adov6vb_r0D.DSP_DNN_RESETN_RF = 1;
        //mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B815
        
        adov6vb_r0D.DSP_DNN_HP_MODE_EN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B835

        adov6vb_r0D.DSP_HP_RESETN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B8B5
        adov6vb_r0D.DSP_HP_FIFO_GO = 1;
        adov6vb_r0D.DSP_HP_ADO_GO = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BBB5
        }
    else if(mode == 0){      //DSP All Off
        adov6vb_r0D.DSP_HP_FIFO_GO = 0;
        adov6vb_r0D.DSP_HP_ADO_GO = 0;
        adov6vb_r0D.DSP_HP_DNN_GO = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BCB5
        adov6vb_r0D.DSP_HP_RESETN = 0;
        adov6vb_r0D.DSP_DNN_HP_MODE_EN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC15
        
        adov6vb_r0D.DSP_DNN_CLKENB_RF_SEL = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
        adov6vb_r0D.DSP_DNN_RESETN_RF = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC05
        adov6vb_r0D.DSP_DNN_CLKENB_RF = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC0D
        adov6vb_r0D.DSP_DNN_ISOLATEN_RF = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC09
        adov6vb_r0D.DSP_DNN_PG_SLEEP_RF = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC0B
        adov6vb_r0D.DSP_DNN_CLKENB_RF_SEL = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
        adov6vb_r0D.DSP_DNN_CTRL_RF_SEL = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC0A
        
        adov6vb_r04.DSP_P2S_MON_EN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//A00040
        
        adov6vb_r04.DSP_P2S_RESETN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//E00040
        
        adov6vb_r0D.DSP_LP_RESETN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC4A
        }
}

static void afe_set_mode(uint8_t mode){
    if(mode == 1){      //LP AFE
        //if(prev20_r19.XO_EN_OUT !=1){// XO ouput enable
        //    prev20_r19.XO_EN_OUT    = 1;
        //    *REG_XO_CONF1 = prev20_r19.as_int;
		//}
        adov6vb_r0D.REC_ADC_RESETN = 0;
        adov6vb_r0D.REC_ADCDRI_EN = 0;
        adov6vb_r0D.REC_LNA_AMPEN = 0;
        adov6vb_r0D.REC_LNA_AMPSW_EN = 0;
        adov6vb_r0D.REC_LNA_OUTSHORT_EN = 0;
        adov6vb_r0D.REC_PGA_AMPEN = 0;
        adov6vb_r0D.REC_PGA_OUTSHORT_EN = 0;
        adov6vb_r0D.VAD_LNA_AMPSW_EN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);
        
        //adov6vb_r13.VAD_PGA_FSETTLE = 0;
        //adov6vb_r13.VAD_LNA_FSETTLE = 1;
        adov6vb_r13.VAD_PGA_OUTSHORT_EN = 0;
										
        adov6vb_r13.VAD_LNA_OUTSHORT_EN = 0;
        adov6vb_r13.LDO_PG_IREF = 0;
        adov6vb_r13.LDO_PG_VREF_0P6LP = 0;
        adov6vb_r13.LDO_PG_LDOCORE_0P6LP = 0;
        adov6vb_r13.LDO_PG_VREF_1P4LP = 0;
        adov6vb_r13.LDO_PG_LDOCORE_1P4LP = 0;
        adov6vb_r13.LDO_PG_VREF_1P4HP = 1;
        adov6vb_r13.LDO_PG_LDOCORE_1P4HP = 1;
        adov6vb_r13.LDO_PG_VREF_0P9HP = 1;
        adov6vb_r13.LDO_PG_LDOCORE_0P9HP = 1;
        mbus_remote_register_write(ADO_ADDR, 0x13, adov6vb_r13.as_int);
		delay(MBUS_DELAY*9);

        adov6vb_r0F.VAD_ADC_RESET = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0F, adov6vb_r0F.as_int);

        adov6vb_r14.VAD_ADCDRI_EN = 1;
        adov6vb_r14.VAD_LNA_AMPEN = 1;
        adov6vb_r14.VAD_PGA_AMPEN = 1;
        adov6vb_r14.VAD_PGA_BWCON = 19;//13;
        adov6vb_r14.VAD_PGA_GCON = 4;//8;
        mbus_remote_register_write(ADO_ADDR, 0x14, adov6vb_r14.as_int);

        ////VAD MON setting can come here
        //adov6vb_r1A.VAD_MONSEL = 1;
        //adov6vb_r1A.VAD_MONBUF_EN = 1;
        //adov6vb_r1A.VAD_REFMONBUF_EN = 0;
        //adov6vb_r1A.VAD_ADCDRI_OUT_OV_EN = 1;
        //adov6vb_r16.IBC_VAD_LNA = 5;
        //adov6vb_r16.IBC_VAD_PGA = 5;
        //mbus_remote_register_write(ADO_ADDR, 0x16, adov6vb_r16.as_int);
        
        ////REC MON setting (debug)
        adov6vb_r17.REC_MONSEL = 0;
        adov6vb_r17.REC_MONBUF_EN = 0;
        //adov6vb_r17.REC_REFMONBUF_EN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x17, adov6vb_r17.as_int);

        adov6vb_r10.DO_LP_HP_SEL = 0;    //0: LP, 1: HP
        adov6vb_r10.DIO_OUT_EN = 1;
        adov6vb_r10.VAD_ADC_DOUT_ISOL = 0;
        mbus_remote_register_write(ADO_ADDR, 0x10, adov6vb_r10.as_int);

        adov6vb_r04.DSP_CLK_MON_SEL = 4; //LP CLK mon
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);
    }
    else if(mode == 2){ // HP AFE
        //if(prev20_r19.XO_EN_OUT !=1){// XO ouput enable
        //    prev20_r19.XO_EN_OUT    = 1;
        //    *REG_XO_CONF1 = prev20_r19.as_int;
        //}
		*EP_MODE= (*EP_MODE | 1);

        adov6vb_r13.LDO_PG_IREF = 0;
        adov6vb_r13.LDO_PG_VREF_0P6LP = 0;
        adov6vb_r13.LDO_PG_LDOCORE_0P6LP = 0;
        adov6vb_r13.LDO_PG_VREF_1P4LP = 0;
        adov6vb_r13.LDO_PG_LDOCORE_1P4LP = 0;
        adov6vb_r13.LDO_PG_VREF_1P4HP = 0;
        adov6vb_r13.LDO_PG_LDOCORE_1P4HP = 0;
        adov6vb_r13.LDO_PG_VREF_0P9HP = 0;
        adov6vb_r13.LDO_PG_LDOCORE_0P9HP = 0;
        mbus_remote_register_write(ADO_ADDR, 0x13, adov6vb_r13.as_int);
		delay(MBUS_DELAY*9);

        //adov6vb_r15.REC_PGA_GCON = 31;
        //mbus_remote_register_write(ADO_ADDR, 0x15, adov6vb_r15.as_int);

        //adov6vb_r16.IBC_REC_LNA = 6;
        //adov6vb_r16.IBC_REC_PGA = 11;
        //mbus_remote_register_write(ADO_ADDR, 0x16, adov6vb_r16.as_int);

        adov6vb_r0D.REC_ADC_RESETN = 1;
        adov6vb_r0D.REC_ADCDRI_EN = 1;
        adov6vb_r0D.REC_LNA_AMPEN = 1;
        adov6vb_r0D.REC_LNA_AMPSW_EN = 1;
        //adov6vb_r0D.REC_LNA_FSETTLE = 1;
        //adov6vb_r0D.REC_PGA_FSETTLE = 0;
        adov6vb_r0D.REC_LNA_OUTSHORT_EN = 0;
        adov6vb_r0D.REC_PGA_AMPEN = 1;
        adov6vb_r0D.REC_PGA_OUTSHORT_EN = 0;
        adov6vb_r0D.VAD_LNA_AMPSW_EN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);
        delay(MBUS_DELAY*9);
        //adov6vb_r0D.REC_LNA_FSETTLE = 0;
        //mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);

        adov6vb_r10.DO_LP_HP_SEL = 1;    //HP
        adov6vb_r10.DIO_OUT_EN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x10, adov6vb_r10.as_int);

        adov6vb_r04.DSP_CLK_MON_SEL = 2; //HP clock mon
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);
    }
    else{       // AFE off
        //if(prev20_r19.XO_EN_OUT !=0){// XO ouput enable
        //    prev20_r19.XO_EN_OUT    = 0; 
        //    *REG_XO_CONF1 = prev20_r19.as_int;
        //}
        
		*EP_MODE = (*EP_MODE & 2);

        adov6vb_r0D.REC_ADC_RESETN = 0;
        adov6vb_r0D.REC_ADCDRI_EN = 0;
        adov6vb_r0D.REC_LNA_AMPEN = 0;
        adov6vb_r0D.REC_LNA_AMPSW_EN = 0;
										
        adov6vb_r0D.REC_LNA_OUTSHORT_EN = 0;
        adov6vb_r0D.REC_PGA_AMPEN = 0;
        adov6vb_r0D.REC_PGA_OUTSHORT_EN = 0;
        adov6vb_r0D.VAD_LNA_AMPSW_EN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);
        
										
										
        adov6vb_r13.LDO_PG_IREF = 0;
        adov6vb_r13.LDO_PG_VREF_0P6LP = 1;
        adov6vb_r13.LDO_PG_LDOCORE_0P6LP = 1;
        adov6vb_r13.LDO_PG_VREF_1P4LP = 1;
        adov6vb_r13.LDO_PG_LDOCORE_1P4LP = 1;
        adov6vb_r13.LDO_PG_VREF_1P4HP = 1;
        adov6vb_r13.LDO_PG_LDOCORE_1P4HP = 1;
        adov6vb_r13.LDO_PG_VREF_0P9HP = 1;
        adov6vb_r13.LDO_PG_LDOCORE_0P9HP = 1;
        mbus_remote_register_write(ADO_ADDR, 0x13, adov6vb_r13.as_int);

        adov6vb_r0F.VAD_ADC_RESET = 1;
        mbus_remote_register_write(ADO_ADDR, 0x0F, adov6vb_r0F.as_int);

        adov6vb_r14.VAD_ADCDRI_EN = 0;
        adov6vb_r14.VAD_LNA_AMPEN = 0;
        adov6vb_r14.VAD_PGA_AMPEN = 0;
        mbus_remote_register_write(ADO_ADDR, 0x14, adov6vb_r14.as_int);

        adov6vb_r10.DIO_OUT_EN = 0;
        //adov6vb_r10.DIO_DIR_IN1OUT0 = 1;
        adov6vb_r10.VAD_ADC_DOUT_ISOL = 1;
        mbus_remote_register_write(ADO_ADDR, 0x10, adov6vb_r10.as_int);
        ////VAD MON setting can come here
        //adov6vb_r1A.VAD_MONSEL = 1;
        //adov6vb_r1A.VAD_MONBUF_EN = 1;
        //adov6vb_r1A.VAD_REFMONBUF_EN = 0;
        //adov6vb_r1A.VAD_ADCDRI_OUT_OV_EN = 1;
        //mbus_remote_register_write(ADO_ADDR, 0x1A, adov6vb_r1A.as_int);
        
        ////REC MON setting (debug)
        //adov6vb_r17.REC_MONSEL = 1;
        //adov6vb_r17.REC_MONBUF_EN = 1;
        //adov6vb_r17.REC_REFMONBUF_EN = 0;
        //mbus_remote_register_write(ADO_ADDR, 0x17, adov6vb_r17.as_int);

    }
}

static void cp_set_mode(uint8_t mode){
    if(mode == 1){ //CP ON
        if(prev20_r19.XO_EN_OUT !=1){// XO ouput enable
            prev20_r19.XO_EN_OUT    = 1;
            *REG_XO_CONF1 = prev20_r19.as_int;
		}
        adov6vb_r14.CP_CLK_EN_1P2 = 1;
        adov6vb_r14.CP_CLK_DIV_1P2 = 0;
        adov6vb_r14.CP_VDOWN_1P2 = 0; //vin = V3P6
        mbus_remote_register_write(ADO_ADDR, 0x14, adov6vb_r14.as_int);
        delay(CP_DELAY); 
        adov6vb_r14.CP_VDOWN_1P2 = 1; //vin = gnd
        mbus_remote_register_write(ADO_ADDR, 0x14, adov6vb_r14.as_int);
	}
    else{ //CP OFF
        adov6vb_r14.CP_CLK_EN_1P2 = 0;
        adov6vb_r14.CP_CLK_DIV_1P2 = 3;
        mbus_remote_register_write(ADO_ADDR, 0x14, adov6vb_r14.as_int);
        
        if(prev20_r19.XO_EN_OUT !=0){// XO ouput enable
            prev20_r19.XO_EN_OUT    = 0; 
            *REG_XO_CONF1 = prev20_r19.as_int;
		}
	}
}


//***************************************************
//  ADO+FLP functions
//***************************************************

inline static void comp_stream(void){
	
    *EP_MODE = (*EP_MODE | 2);
    delay(200000); // Compression-length control: ~14s
    
    cp_set_mode(1); // ADO CP ON
    afe_set_mode(2); // ADO HP AFE ON
	
	delay(600000); // delay needed to get ADC to be responsive
	
    // Flash setup and start /////
    FLASH_turn_on();
    FLASH_pp_ready();
    FLASH_pp_on();
    /////////////////////////////
	
    digital_set_mode(3); // HP Compression only start
    
    delay(200000); // Compression-length control: ~14s
	
    freeze_gpio_out();
    set_wakeup_timer(300,1,1);    //enable timer
    //mbus_write_message32(MBUS_POWER, (MBUS_SLEEP_BY_SHORT_PREFIX << 28) | 0x00002000);
    //mbus_write_message32(0x01, 0x20002000);
    mbus_write_message32(0x01, 0x27CEE000); // selective sleep except ADO and FLP1
    //mbus_write_message32(0x01, 0x27FDE000); // selective sleep except ADO
    //mbus_write_message32(0x01, 0x27FFE000); // selective sleep for all layers
	
	
}

inline static void comp_finish(void){
	
    *EP_MODE = (*EP_MODE & 1);
    digital_set_mode(0); // ADO DSP ALL OFF
    afe_set_mode(0); // ADO AFE OFF
    delay(10000);
    cp_set_mode(0); // ADO CP OFF
	
    FLASH_pp_off();
    FLASH_turn_off();
}


inline static void comp_stream_read(void){
	
    *EP_MODE = (*EP_MODE | 2);
    delay(200000); // Compression-length control: ~14s
    
    cp_set_mode(1); // ADO CP ON
    afe_set_mode(2); // ADO HP AFE ON
	
    // Flash setup and start /////
    FLASH_turn_on();
    FLASH_pp_ready();
    FLASH_pp_on();
    /////////////////////////////
	
    digital_set_mode(3); // HP Compression only start
    
    delay(800000); // Compression-length control: ~14s
	
    //freeze_gpio_out();
    //set_wakeup_timer(300,1,1);    //enable timer
    //mbus_write_message32(MBUS_POWER, (MBUS_SLEEP_BY_SHORT_PREFIX << 28) | 0x00002000);
    //mbus_write_message32(0x01, 0x20002000);
    //mbus_write_message32(0x01, 0x27CEE000); // selective sleep except ADO and FLP1
    //mbus_write_message32(0x01, 0x27FDE000); // selective sleep except ADO
    //mbus_write_message32(0x01, 0x27FFE000); // selective sleep for all layers
	
	comp_finish();
	
	FLASH_read_8k();
	
}


inline static void flash_erasedata(void){
    FLASH_turn_on();
    FLASH_pp_ready();
    FLASH_turn_off();
    /////////////////////////////
}

static void operation_tx_stored_8k(){
	
    //Fire off stored data to radio
    uint32_t flp_sram_addr = 0;
	uint16_t j;
	uint16_t k;
	
    // Flash Read
	FLASH_turn_on();
	for (k=0; k<1; k++){ //not 8M right now - make this 1024 for 8M
		mbus_remote_register_write (FLP1_ADDR, 0x08 , k*8192); // Set FLSH_START_ADDR
		mbus_remote_register_write (FLP1_ADDR, 0x07 , 0x0); // Set SRAM_START_ADDR
	
		prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x0; //disable watchdog for long access
		*REG_MBUS_WD = prev20_r1F.as_int;
	
		set_halt_until_mbus_rx();
		mbus_remote_register_write (FLP1_ADDR, 0x09 , 0x07FFE3); // Flash -> SRAM
		set_halt_until_mbus_tx();
	
		prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x16E360; //set watchdog back to default
		*REG_MBUS_WD = prev20_r1F.as_int;

		if (*REG1 != 0x00002B) flp_fail(4);
    
		// Radio Transmission
		for(j=0; j<4096; j++){
 
			// Reset watchdog timer
			//config_timerwd(TIMERWD_VAL);
	
			// Radio out data
			uint32_t mem_read_data[2];
			set_halt_until_mbus_rx();
			// Read 2 words (4 data points) at a time
			mbus_copy_mem_from_remote_to_any_bulk(FLP1_ADDR, (uint32_t*) flp_sram_addr, 0x01, (uint32_t*)&mem_read_data, 1);
			set_halt_until_mbus_tx();
	
			send_audio_mrr(0, 0x4, j, mem_read_data[0], mem_read_data[1]);
			flp_sram_addr = flp_sram_addr + 8;
		}
	}
	
    // Turn off Flash
    FLASH_turn_off();
	
}

static void operation_tx_stored_8M(){
	
    //Fire off stored data to radio
    uint32_t flp_sram_addr = 0;
	uint16_t j;
	uint16_t k;
	
    // Flash Read
	FLASH_turn_on();
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x0; //disable watchdog for long access
	*REG_MBUS_WD = prev20_r1F.as_int;
	
	for (k=0; k<4; k++){ //not 8M right now - make this 1024 for 8M
		mbus_remote_register_write (FLP1_ADDR, 0x08 , k*8192); // Set FLSH_START_ADDR
		mbus_remote_register_write (FLP1_ADDR, 0x07 , 0x0); // Set SRAM_START_ADDR
	
		set_halt_until_mbus_rx();
		mbus_remote_register_write (FLP1_ADDR, 0x09 , 0x07FFE3); // Flash -> SRAM
		set_halt_until_mbus_tx();
	
		if (*REG1 != 0x00002B) flp_fail(4);
    
		// Radio Transmission
		for(j=0; j<4096; j++){
 
			// Reset watchdog timer
			//config_timerwd(TIMERWD_VAL);
	
			// Radio out data
			uint32_t mem_read_data[2];
			set_halt_until_mbus_rx();
			// Read 2 words (4 data points) at a time
			mbus_copy_mem_from_remote_to_any_bulk(FLP1_ADDR, (uint32_t*) flp_sram_addr, 0x01, (uint32_t*)&mem_read_data, 1);
			set_halt_until_mbus_tx();
	
			send_audio_mrr(0, 0x4, j, mem_read_data[0], mem_read_data[1]);
			//mbus_write_message32(0xC0, mem_read_data[0]);
			//mbus_write_message32(0xC0, mem_read_data[1]);
			flp_sram_addr = flp_sram_addr + 8;
		}
	}
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x16E360; //set watchdog back to default
	*REG_MBUS_WD = prev20_r1F.as_int;
    // Turn off Flash
    FLASH_turn_off();
	
}

/*
static void operation_tx_stored_short(){
	
    //Fire off stored data to radio
    uint32_t flp_sram_addr = 0;
	uint16_t j;
	
    // Flash Read
    FLASH_turn_on();
    mbus_remote_register_write (FLP1_ADDR, 0x08 , 0x0); // Set FLSH_START_ADDR
    mbus_remote_register_write (FLP1_ADDR, 0x07 , 0x0); // Set SRAM_START_ADDR
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x0; //disable watchdog for long access
	*REG_MBUS_WD = prev20_r1F.as_int;
	
    set_halt_until_mbus_rx();
    mbus_remote_register_write (FLP1_ADDR, 0x09 , 0x04AAA3); // Flash -> SRAM
    set_halt_until_mbus_tx();
	
	prev20_r1F.MBUS_WATCHDOG_THRESHOLD = 0x16E360; //set watchdog back to default
	*REG_MBUS_WD = prev20_r1F.as_int;

	if (*REG1 != 0x00002B) flp_fail(4);
    
    // Radio Transmission
	for(j=0; j<1365; j++){
 
		// Reset watchdog timer
		//config_timerwd(TIMERWD_VAL);
	
		// Radio out data
		uint32_t mem_read_data[2];
		set_halt_until_mbus_rx();
		// Read 2 words (4 data points) at a time
		mbus_copy_mem_from_remote_to_any_bulk(FLP1_ADDR, (uint32_t*) flp_sram_addr, 0x01, (uint32_t*)&mem_read_data, 1);
		set_halt_until_mbus_tx();
	
		send_audio_mrr(0, 0x4, j, mem_read_data[0], mem_read_data[1]);
		flp_sram_addr = flp_sram_addr + 8;
    }
	
    // Turn off Flash
    FLASH_turn_off();
	
}
*/

//***************************************************
// End of Program Sleep Operation
//***************************************************

static void operation_sleep(void){
    // Reset GOC_DATA_IRQ
    *GOC_DATA_IRQ = 0;
	
    // Freeze GPIO
    freeze_gpio_out();
	
    // Go to Sleep
    mbus_sleep_all();
    while(1);
}


static void operation_sleep_timer(void){
    // Make sure the irq counter is reset    
    //exec_count_irq = 0;
	
    set_wakeup_timer(300,1,1);    //enable timer
    //set_xo_timer(0,1600,1,1);
    //start_xo_cnt();
    //mbus_sleep_all();
	
    // Go to sleep
    operation_sleep();
}


static void operation_sleep_notimer(void){
    // Make sure the irq counter is reset    
    //exec_count_irq = 0;
    
    // Make sure Radio is off
    //if (radio_on){
    //    radio_power_off();
//}

set_wakeup_timer(0,0,0);    //disable timer
//set_xo_timer(0,1600,1,1);
//start_xo_cnt();
//mbus_sleep_all();

// Go to sleep
operation_sleep();
}



//***************************************************
// Initialization
//***************************************************
static void operation_init(void){
    //pmu_sar_conv_ratio_val_test_on = 0x4A;
    pmu_sar_conv_ratio_val_test_on = 0x2E;//0x2D;
    pmu_sar_conv_ratio_val_test_off = 0x2C;//0x2A;
	
	
    // Config watchdog timer to about 10 sec; default: 0x02FFFFFF
    //config_timerwd(TIMERWD_VAL);
    *TIMERWD_GO = 0x0;
    *REG_MBUS_WD = 0;
	
    // EP Mode
    *EP_MODE = 0;
	
    // Set CPU & Mbus Clock Speeds
    //prev20_r0B.CLK_GEN_RING = 0x1; // Default 0x1
    //prev20_r0B.CLK_GEN_DIV_MBC = 0x1; // Default 0x1
    //prev20_r0B.CLK_GEN_DIV_CORE = 0x2; // Default 0x3
    //prev20_r0B.GOC_CLK_GEN_SEL_FREQ = 0x5; // Default 0x6
    //prev20_r0B.GOC_CLK_GEN_SEL_DIV = 0x0; // Default 0x0
    //prev20_r0B.GOC_SEL = 0xF; // Default 0x8
	//*REG_CLKGEN_TUNE = prev20_r0B.as_int;
	
    prev20_r1C.SRAM0_TUNE_ASO_DLY = 31; // Default 0x0, 5 bits
    prev20_r1C.SRAM0_TUNE_DECODER_DLY = 15; // Default 0x2, 4 bits
    //prev20_r1C.SRAM0_USE_INVERTER_SA= 0; // Default 0x0, 1bit
    *REG_SRAM0_TUNE = prev20_r1C.as_int;
	
    //Enumerate & Initialize Registers
    enumerated = ENUMID;
    //exec_count = 0;
    //exec_count_irq = 0;
    //PMU_ADC_3P0_VAL = 0x62;
    //pmu_parkinglot_mode = 3;
	
    //Enumeration
    mbus_enumerate(SNT_ADDR);
    delay(MBUS_DELAY);
    mbus_enumerate(MRR_ADDR);
    delay(MBUS_DELAY);
    mbus_enumerate(FLP1_ADDR);
    delay(MBUS_DELAY);
    mbus_enumerate(FLP2_ADDR);
    delay(MBUS_DELAY);
    mbus_enumerate(FLP3_ADDR);
    delay(MBUS_DELAY);
    mbus_enumerate(FLP4_ADDR);
    delay(MBUS_DELAY);
    mbus_enumerate(ADO_ADDR);
    delay(MBUS_DELAY);
    mbus_enumerate(PMU_ADDR);
    delay(MBUS_DELAY);
	
    // Set CPU Halt Option as TX --> Use for register write e.g.
    //    set_halt_until_mbus_tx();
	
	
    // PMU Settings ----------------------------------------------
    mbus_remote_register_write(PMU_ADDR,0x51, 
		( (1 << 0) // LC_CLK_RING=1; default 1
			| (3 << 2) // LC_CLK_DIV=3; default 3
			| (0 << 4) // PMU_IRQ_EN=0; default 1
		));
		
		pmu_set_clk_init();
		pmu_reset_solar_short();
		
		// Disable PMU ADC measurement in active mode
		// PMU_CONTROLLER_STALL_ACTIVE
		mbus_remote_register_write(PMU_ADDR,0x3A, 
            ( (1 << 19) // ignore state_horizon; default 1
				| (1 << 13) // ignore adc_output_ready; default 0
				| (1 << 12) // ignore adc_output_ready; default 0
				| (1 << 11) // ignore adc_output_ready; default 0
			));
			delay(MBUS_DELAY);
			pmu_adc_reset_setting();
			delay(MBUS_DELAY);
			pmu_adc_enable();
			delay(MBUS_DELAY);
			
			// Initialize other global variables
			wakeup_data = 0;
			num_total_16b_packet = 200; //total 1000 words transmission
			radio_tx_option = 0; //enables radio tx for each measurement 
			radio_ready = 0;
			radio_on = 0;
			RADIO_PACKET_DELAY = 2000;
			//radio_packet_count = 0;
			read_data_batadc_diff = 0;
			
			TEMP_CALIB_A = 240000;
			TEMP_CALIB_B = 3750000;
			NUM_MEAS_USER = TEMP_STORAGE_SIZE;
			
			//#ifdef DEBUG_MODE
			*REG_CPS = 0x5;   //both TEST VDD on [2]=1: Test 1.2V on,  [0]=1: Test 0.6V on
			//#else
			//    *REG_CPS = 0x0;   //both TEST VDD off
			//#endif
			delay(MBUS_DELAY*10);
			
			FLASH_initialization(); //FLPv3L initialization
			ado_initialization(); //ADOv6VB initialization
			mrr_init();
			XO_init(); //XO initialization
			
			// Self boot. Offchip NMOS gate control via gpio[7]
			direction_gpio = 0x80; //set gpio[7] direction as output for selfboot support, the others are input
			gpio_set_data(0x80);  // gpio[7]=1 
			init_gpio();
			
			*TIMERWD_GO = 0x0;
			*REG_MBUS_WD = 0;
}

//*******************************************************************
// INTERRUPT HANDLERS 
//*******************************************************************

void handler_ext_int_wakeup   (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_gocep    (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_timer32  (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg0     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg1     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg2     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg3     (void) __attribute__ ((interrupt ("IRQ")));

void handler_ext_int_wakeup(void) { // WAKE-UP
    *NVIC_ICPR = (0x1 << IRQ_WAKEUP); 
    delay(MBUS_DELAY);
    // Report who woke up
	#ifdef DEBUG_MBUS_MSG
		mbus_write_message32(0xE4,*SREG_WAKEUP_SOURCE); 
	#endif    
    //[ 0] = GOC/EP
    //[ 1] = Wakeuptimer
    //[ 2] = XO timer
    //[ 3] = gpio_pad
    //[ 4] = mbus message
    //[ 8] = gpio[0]
    //[ 9] = gpio[1]
    //[10] = gpio[2]
    //[11] = gpio[3////]
    //if(((*SREG_WAKEUP_SOURCE >> 8) & 1) == 1){ //waked up by gpio[0]
    //    //Do something
    //    delay(MBUS_DELAY*100); //~1sec
//}
//else if(((*SREG_WAKEUP_SOURCE >> 9) & 1) == 1){ //waked up by gpio[1]
//    //Do something
//    delay(MBUS_DELAY*200); //~2sec
//}
//else if(((*SREG_WAKEUP_SOURCE >> 10) & 1) == 1){ //waked up by gpio[2]
//    //Do something
//    delay(MBUS_DELAY*400); //~4sec
//}
//else if(((*SREG_WAKEUP_SOURCE >> 11) & 1) == 1){ //waked up by gpio[3]
//    //Do something
//    delay(MBUS_DELAY*800); //~8sec
//}   
if(((*SREG_WAKEUP_SOURCE >> 1) & 1) == 1){ //waked up by wakeup timer
	
	if (((*EP_MODE >> 1) & 1) == 0){
		comp_stream();
	}
	else{

		comp_finish();
		FLASH_read_8M();
		*NVIC_IPR0 = 0x00800040; //allow for other interrupts to be handled
		radio_power_on();
		operation_tx_stored_8M();
	}
	
	delay(MBUS_DELAY*200); //~2sec
}   

}
void handler_ext_int_timer32(void) { // TIMER32
    *NVIC_ICPR = (0x1 << IRQ_TIMER32);
    *REG1 = *TIMER32_CNT;
    *REG2 = *TIMER32_STAT;
    *TIMER32_STAT = 0x0;
    wfi_timeout_flag = 1;
	//set_halt_until_mbus_tx();
}
void handler_ext_int_reg0(void) { // REG0
    *NVIC_ICPR = (0x1 << IRQ_REG0);
	#ifdef DEBUG_MBUS_MSG
		mbus_write_message32(0xE0, *REG0);
	#endif    
    if(*REG0 == 1){ // LP -> HP mode change
        *EP_MODE = (*EP_MODE | 1);
		
		adov6vb_r0D.DSP_DNN_CLKENB_RF = 0;
		mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B805
		adov6vb_r0D.DSP_DNN_PG_SLEEP_RF = 0;
		mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B809
		adov6vb_r0D.DSP_DNN_ISOLATEN_RF = 1;
		mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80D
		adov6vb_r0D.DSP_DNN_RESETN_RF = 1;
		mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B815
		adov6vb_r0D.DSP_DNN_CTRL_RF_SEL = 1;
		mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
		adov6vb_r0D.DSP_DNN_CLKENB_RF_SEL = 1;
		mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
		adov6vb_r0E.DSP_DNN_DBG_MODE_EN = 1;
		mbus_remote_register_write(ADO_ADDR, 0x0E, adov6vb_r0E.as_int);//000054
		
		adov6vb_r0D.DSP_LP_RESETN = 0;
		mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80A
		
		afe_set_mode(2);
		digital_set_mode(2);
	}
    else if(*REG0 == 0) { // HP -> ULP mode change
        *EP_MODE = (*EP_MODE & 2);
        adov6vb_r0D.DSP_HP_FIFO_GO = 0;
        adov6vb_r0D.DSP_HP_ADO_GO = 0;
        adov6vb_r0D.DSP_HP_DNN_GO = 0;
        mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BCB5
        
        afe_set_mode(1);
        digital_set_mode(1);
        
        operation_sleep_notimer();
	}
	#ifdef DEBUG_MBUS_MSG
		mbus_write_message32(0xE1, *EP_MODE);
	#endif    
}
void handler_ext_int_reg1(void) { // REG1
    *NVIC_ICPR = (0x1 << IRQ_REG1);
}
void handler_ext_int_reg2(void) { // REG2
    *NVIC_ICPR = (0x1 << IRQ_REG2);
	#ifdef DEBUG_MBUS_MSG
		mbus_write_message32(0xE0, *REG2);
	#endif  
}
void handler_ext_int_reg3(void) { // REG3
    *NVIC_ICPR = (0x1 << IRQ_REG3);
}
void handler_ext_int_gocep(void) { // GOCEP
    *NVIC_ICPR = (0x1 << IRQ_GOCEP);

	#ifdef DEBUG_MBUS_MSG
		mbus_write_message32(0xEE,  *GOC_DATA_IRQ);
	#endif    
    wakeup_data = *GOC_DATA_IRQ;
    uint32_t data_cmd = (wakeup_data>>24) & 0xFF;
    uint32_t data_val = wakeup_data & 0xFF;
    //uint32_t data_val2 = (wakeup_data>>8) & 0xFF;
    if(data_cmd == 0x01){       // Charge pump control
        cp_set_mode(data_val);
	}
    else if(data_cmd == 0x02){  // SRAM Programming mode
        if(data_val==1){    //Enter
            adov6vb_r0E.DSP_DNN_DBG_MODE_EN = 1;
            mbus_remote_register_write(ADO_ADDR, 0x0E, adov6vb_r0E.as_int);//000054
            adov6vb_r0D.DSP_DNN_CTRL_RF_SEL = 1;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
            adov6vb_r0D.DSP_DNN_CLKENB_RF_SEL = 1;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
            adov6vb_r0D.DSP_DNN_PG_SLEEP_RF = 0;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B809
            adov6vb_r0D.DSP_DNN_ISOLATEN_RF = 1;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80D
            adov6vb_r0D.DSP_DNN_CLKENB_RF = 0;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B805
            adov6vb_r0D.DSP_DNN_RESETN_RF = 1;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B815
		}
        else{               //Exit
            adov6vb_r0D.DSP_DNN_RESETN_RF = 0;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B805
            adov6vb_r0D.DSP_DNN_CLKENB_RF = 1;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80D
            adov6vb_r0D.DSP_DNN_ISOLATEN_RF = 0;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B809
            adov6vb_r0D.DSP_DNN_PG_SLEEP_RF = 1;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
            adov6vb_r0D.DSP_DNN_CLKENB_RF_SEL = 0;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80B
            adov6vb_r0D.DSP_DNN_CTRL_RF_SEL = 0;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03B80A
            adov6vb_r0E.DSP_DNN_DBG_MODE_EN = 0;
            mbus_remote_register_write(ADO_ADDR, 0x0E, adov6vb_r0E.as_int);//000050
		}
	}
    else if(data_cmd == 0x03){  // DSP Monitoring Configure
        adov6vb_r04.DSP_P2S_MON_EN = 1;
        adov6vb_r04.DSP_CLK_MON_SEL = 4;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//A00040
        adov6vb_r04.DSP_P2S_RESETN = 1;
        mbus_remote_register_write(ADO_ADDR, 0x04, adov6vb_r04.as_int);//E00040
	}
    else if(data_cmd == 0x04){  // DSP LP Control
        if(data_val==1){    //Go
            adov6vb_r0D.DSP_LP_RESETN = 1;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC4A
		}
        else{               //Stop
            adov6vb_r0D.DSP_LP_RESETN = 0;
            mbus_remote_register_write(ADO_ADDR, 0x0D, adov6vb_r0D.as_int);//03BC0A
		}
	}
    else if(data_cmd == 0x05){  // AFE Control
		*REG_CPS = 0x5;
        afe_set_mode(data_val);
        if(data_val == 2) {
			digital_set_mode(3); // HP Compression only start
			delay(100000); //~10sec, AFE HP test purpose
		}
        else if(data_val == 0) {
			digital_set_mode(0);
		}
	}
    else if(data_cmd == 0x06){  // Compression + Flash Test
        if(data_val==1){    //Go
			*REG_CPS = 0x5;
			*NVIC_IPR0 = 0x00800040; //allow for other interrupts to be handled
            comp_stream();
		}
        //else if(data_val==2){
        //    FLASH_read();
	//}
}


//    else if(data_cmd == 0x07){ //Power gate control
//        if(data_val == 0) { //both TEST VDD off
//            *REG_CPS = 0;
//            pmu_set_sar_override(pmu_sar_conv_ratio_val_test_off);
//            pmu_set_sleep_clk(0xA,0xA,0xF,0xA);
//            pmu_set_active_clk(0xA,0x4,0x10,0x4);
//        }
//        else if(data_val == 2){ //both TEST VDD on
//            pmu_set_sar_override(pmu_sar_conv_ratio_val_test_on);
//            pmu_set_sleep_clk(0xA,0x1,0x10,0x2);
//            pmu_set_active_clk(0xA,0x1,0x10,0x2);
//            *REG_CPS = 0x5; 
//        }
//        else if(data_val == 3){ //both TEST VDD on, active mode
//            pmu_set_sar_override(pmu_sar_conv_ratio_val_test_on);
//            pmu_set_sleep_clk(0xA,0x4,0x10,0x4);
//            pmu_set_active_clk(0xA,0x4,0x10,0x4);
//            *REG_CPS = 0x5; 
//        }
//        //*REG_CPS = 0x7 & data_val;
//    }
//    else if(data_cmd == 0x08){ //Power gate control
//        *REG_CPS = 0x7 & data_val;
//    }
//    else if(data_cmd == 0x09){
//        if(data_val != 0xF) pmu_set_sleep_clk(data_val+1,data_val,data_val2,data_val);
//        else pmu_set_sleep_clk(data_val,data_val,data_val2,data_val);
//    }
//    else if(data_cmd == 0x0A){
//        if(data_val != 0xF) pmu_set_active_clk(data_val+1,data_val,data_val2,data_val);
//        else pmu_set_active_clk(data_val,data_val,data_val2,data_val);
//        delay(MBUS_DELAY*300); //~3sec
//    }
//    else if(data_cmd == 0x0B){
//        pmu_set_sar_override(data_val);
//    }
//    else if(data_cmd == 0x10){  //GPIO direction, trigger
//        direction_gpio = data_val | 0x80; // input:0, output:1,  eg. 0xF0 set GPIO[7:4] as output, GPIO[3:0] as input 
//        init_gpio();
//        config_gpio_posedge_wirq((data_val2>>4)&0xF);
//        config_gpio_negedge_wirq(data_val2&0xF);
//    }
//    else if(data_cmd == 0x11){ //GPIO set (only for pins set as output)
//        gpio_set_data( data_val | 0x80 );   // GPIO[7] should be always 1 for self-boot
//        gpio_write_current_data();
//        delay(MBUS_DELAY*100);      //~1sec delay
//        gpio_set_data( data_val2 | 0x80 );   // since data is overwritten here
//        mbus_write_message32(0xE5, *GPIO_DATA);
//        gpio_write_current_data();  // and GPIO out values change here
//        mbus_write_message32(0xE5, *GPIO_DATA);
//    }

else if(data_cmd == 0x12){ //MOD Demo Operation
	if(data_val == 1) { //Go to sleep with wakeup timer setting
		operation_sleep_timer();   // Sleep after wakeup timer set
	}
	else if(data_val == 2) { //Copy the stored audio from FLP to PRE
		FLASH_read_8k();   // Sleep after wakeup timer set
	}
	else if(data_val == 3) {
		mbus_write_message32(0x01, 0x27FB8000); // selective sleep except PRE, FLP1, and SRR
		//radio_power_on();
		//operation_tx_stored(0);
	}
}

else if(data_cmd == 0x13){ //radio packet blaster
	uint32_t i;
	radio_power_on();
	*NVIC_IPR0 = 0x00400000; //allow for other interrupts to be handled
	mbus_write_message32(0xD0,0xABCD1234); 
	for (i = 0; i < data_val; i++){
		send_radio_data_mrr(0,0x4,(0x18170000 | i));
		delay(3000);
		mbus_write_message32(0xD1,i); 
	}
	mbus_write_message32(0xD2,0x98765432); 	
	send_radio_data_mrr(1,0x4,0x1817DDDD);
}

else if(data_cmd == 0x14){ //radio out first 8k of flash
	radio_power_on();
	*NVIC_IPR0 = 0x00400000; //allow for other interrupts to be handled
	mbus_write_message32(0xDA, 0xABABABAB);
	operation_tx_stored_8M();
	mbus_write_message32(0xDF, 0xEFEFEFEF);
}

else if(data_cmd == 0x15){ //flash erase
	mbus_write_message32(0xDA, 0x23232323);
	flash_erasedata();
	mbus_write_message32(0xDF, 0x89898989);
}
else if(data_cmd == 0x16){ //flash read 8k
	mbus_write_message32(0xDA, 0xABABABAB);
	FLASH_read_8k();
	mbus_write_message32(0xDF, 0xEFEFEFEF);
}
else if(data_cmd == 0x17){ //flash read 8M
	mbus_write_message32(0xDA, 0xABABABAB);
	FLASH_read_8M();
	mbus_write_message32(0xDF, 0xEFEFEFEF);
}

else if(data_cmd == 0x18){ //flash prog A's & 5's first 8k
	mbus_write_message32(0xDA, 0x12121212);
	flash_erasedata();
	mbus_write_message32(0xDA, 0x23232323);
	flpv3l_sram_write_all(2); // write AAAA
	mbus_write_message32(0xDA, 0x34343434);
	FLASH_prog_8k();
	mbus_write_message32(0xDA, 0x45454545);
	flpv3l_sram_write_all(0); // write 0000
	mbus_write_message32(0xDA, 0x56565656);
	FLASH_read_8k();
	mbus_write_message32(0xDA, 0x67676767);
	flash_erasedata();
	mbus_write_message32(0xDA, 0x78787878);
	flpv3l_sram_write_all(3); // write 5555
	mbus_write_message32(0xDA, 0x89898989);
	FLASH_prog_8k();
	mbus_write_message32(0xDA, 0x9A9A9A9A);
	flpv3l_sram_write_all(0); // write 0000
	mbus_write_message32(0xDA, 0xABABABAB);
	FLASH_read_8k();
	mbus_write_message32(0xDA, 0xBCBCBCBC);
}

else if(data_cmd == 0x19){ //radio out first 8k of flash
	radio_power_on();
	*NVIC_IPR0 = 0x00400000; //allow for other interrupts to be handled
	mbus_write_message32(0xDA, 0xABABABAB);
	operation_tx_stored_8k();
	mbus_write_message32(0xDF, 0xEFEFEFEF);
}

#ifdef DEBUG_MBUS_MSG
    mbus_write_message32(0xEE, 0x00000E2D);
#endif
}



//********************************************************************
// MAIN function starts here             
//********************************************************************

int main() {
    *TIMERWD_GO = 0x0;
	*REG_CPS = 0x5;
	
    if (enumerated != ENUMID) operation_init();
	
    if((*EP_MODE & 1) != 1) init_gpio();      //when not in memory program mode
    
    
    *NVIC_ISER = (1 << IRQ_WAKEUP) | (1 << IRQ_GOCEP) | (1 << IRQ_TIMER32) | (1 << IRQ_REG0)| (1 << IRQ_REG1)| (1 << IRQ_REG2)| (1 << IRQ_REG3);
    // Initialization sequence
    if ((*EP_MODE & 1) == 1) {
        while (1); 
        //config_timerwd(TIMERWD_VAL);
	}
    else {
        operation_sleep_notimer();
	}
    return 0;
}
